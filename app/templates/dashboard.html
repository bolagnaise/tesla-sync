{% extends "base.html" %}

{% block content %}
    <style>
        #import-selector:hover, #export-selector:hover {
            opacity: 0.85;
        }
    </style>

    <hgroup style="margin-bottom: 2rem; text-align: center;">
        <h1>Dashboard</h1>
        <h2>Real-time energy monitoring and pricing</h2>
    </hgroup>

    <!-- API Connection Status -->
    <article id="connection-status" style="max-width: 800px; padding: 0.75rem; margin: 0 auto 1rem auto;">
        <header style="margin-bottom: 0.5rem; text-align: center;"><strong>Connection Status</strong></header>
        {% set num_cols = 2 + (1 if solar_curtailment_enabled else 0) + (1 if inverter_curtailment_enabled else 0) %}
        <div style="display: grid; grid-template-columns: repeat({{ num_cols }}, 1fr); gap: 0.75rem;">
            <div id="amber-status" class="status-box">
                <h4 style="margin: 0 0 0.25em 0; font-size: 0.85em;">‚ö° Amber Electric</h4>
                <div id="amber-status-content">
                    <p style="margin: 0; font-size: 0.8em;" class="text-muted">Checking connection...</p>
                </div>
            </div>
            <div id="tesla-status" class="status-box">
                <h4 style="margin: 0 0 0.25em 0; font-size: 0.85em;">üîã Tesla Energy
                    <span style="font-weight: normal; font-size: 0.85em;" class="text-muted">
                        via {% if tesla_api_provider == 'fleet_api' %}Fleet API{% else %}Teslemetry{% endif %}
                    </span>
                </h4>
                <div id="tesla-status-content">
                    <p style="margin: 0; font-size: 0.8em;" class="text-muted">Checking connection...</p>
                </div>
            </div>
            {% if solar_curtailment_enabled %}
            <div id="curtailment-status" class="status-box">
                <h4 style="margin: 0 0 0.25em 0; font-size: 0.85em;">üåû DC Curtailment</h4>
                <div id="curtailment-status-content">
                    <p style="margin: 0; font-size: 0.8em;" class="text-muted">Checking status...</p>
                </div>
            </div>
            {% endif %}
            {% if inverter_curtailment_enabled %}
            <div id="ac-inverter-status" class="status-box">
                <h4 style="margin: 0 0 0.25em 0; font-size: 0.85em;">‚òÄÔ∏è AC Inverter</h4>
                <div id="ac-inverter-status-content">
                    <p style="margin: 0; font-size: 0.8em;" class="text-muted">Checking status...</p>
                </div>
            </div>
            {% endif %}
        </div>
    </article>

    <!-- Manual Battery Controls -->
    <article id="discharge-controls" style="max-width: 800px; padding: 0.75rem; margin: 0 auto 1rem auto;">
        <header style="margin-bottom: 0.5rem; text-align: center;"><strong>üîã Manual Battery Control</strong></header>
        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.75rem;">
            <div style="text-align: center;">
                <button id="force-charge-btn" onclick="showChargeModal()" class="primary" style="width: 100%; padding: 0.75rem;">
                    üîå Force Charge
                </button>
            </div>
            <div style="text-align: center;">
                <button id="force-discharge-btn" onclick="showDischargeModal()" class="contrast" style="width: 100%; padding: 0.75rem;">
                    ‚ö° Force Discharge
                </button>
            </div>
            <div style="text-align: center;">
                <button id="restore-normal-btn" onclick="restoreNormal()" class="secondary" style="width: 100%; padding: 0.75rem;">
                    üîÑ Restore Normal
                </button>
            </div>
        </div>
        <div id="discharge-status" style="display: none; margin-top: 0.75rem; padding: 0.5rem; border-radius: 0.5rem; background: rgba(234, 179, 8, 0.2); text-align: center;">
            <span id="discharge-status-text"></span>
        </div>
    </article>

    <!-- Force Discharge Modal -->
    <dialog id="discharge-modal">
        <article style="max-width: 400px;">
            <header>
                <strong>‚ö° Force Discharge</strong>
            </header>
            <p>Select how long to force battery discharge. The battery will export at maximum rate during this period.</p>
            <label for="discharge-duration">Duration</label>
            <select id="discharge-duration">
                <option value="15">15 minutes</option>
                <option value="30" selected>30 minutes</option>
                <option value="45">45 minutes</option>
                <option value="60">1 hour</option>
                <option value="75">1 hour 15 min</option>
                <option value="90">1 hour 30 min</option>
                <option value="105">1 hour 45 min</option>
                <option value="120">2 hours</option>
            </select>
            <footer>
                <button class="secondary" onclick="closeDischargeModal()">Cancel</button>
                <button onclick="activateForceDischarge()">Activate</button>
            </footer>
        </article>
    </dialog>

    <!-- Force Charge Modal -->
    <dialog id="charge-modal">
        <article style="max-width: 400px;">
            <header>
                <strong>üîå Force Charge</strong>
            </header>
            <p>Select how long to force battery charging from grid. The battery will charge at maximum rate during this period.</p>
            <label for="charge-duration">Duration</label>
            <select id="charge-duration">
                <option value="15">15 minutes</option>
                <option value="30" selected>30 minutes</option>
                <option value="45">45 minutes</option>
                <option value="60">1 hour</option>
                <option value="75">1 hour 15 min</option>
                <option value="90">1 hour 30 min</option>
                <option value="105">1 hour 45 min</option>
                <option value="120">2 hours</option>
            </select>
            <footer>
                <button class="secondary" onclick="closeChargeModal()">Cancel</button>
                <button onclick="activateForceCharge()">Activate</button>
            </footer>
        </article>
    </dialog>

    <!-- AEMO Wholesale Price Monitor -->
    <article id="aemo-price-monitor" style="display: none; background: var(--ps-surface-elevated); padding: 1.5em; margin-top: 2rem; border-left: 4px solid var(--ps-success);">
        <header style="text-align: center; margin-bottom: 1em;">
            <strong style="font-size: 0.9em; text-transform: uppercase; letter-spacing: 1px;">‚ö° AEMO Wholesale Price</strong>
            <div id="aemo-region" style="font-size: 0.9em; font-weight: normal; margin-top: 0.3em; opacity: 0.9;">--</div>
        </header>
        <div style="display: flex; justify-content: center; gap: 2em; margin-bottom: 1em;">
            <div style="text-align: center;">
                <div id="aemo-price-display" style="background: rgba(255, 255, 255, 0.15); border-radius: 12px; padding: 1.5em; min-width: 200px;">
                    <div style="font-size: 0.8em; opacity: 0.9; margin-bottom: 0.5em;">Current Price</div>
                    <div id="aemo-current-price" style="font-size: 3em; font-weight: bold; line-height: 1;">--</div>
                    <div style="font-size: 0.9em; opacity: 0.8; margin-top: 0.3em;">$/MWh</div>
                </div>
            </div>
            <div style="text-align: center;">
                <div style="background: rgba(255, 255, 255, 0.1); border-radius: 12px; padding: 1.5em; min-width: 150px;">
                    <div style="font-size: 0.8em; opacity: 0.9; margin-bottom: 0.5em;">Threshold</div>
                    <div id="aemo-threshold" style="font-size: 2.5em; font-weight: bold; line-height: 1;">--</div>
                    <div style="font-size: 0.9em; opacity: 0.8; margin-top: 0.3em;">$/MWh</div>
                </div>
            </div>
        </div>
        <div id="aemo-status-indicator" style="text-align: center; padding: 1em; border-radius: 8px; background: rgba(255, 255, 255, 0.1);">
            <div id="aemo-status-text" style="font-size: 1.1em; font-weight: bold;">Normal Pricing</div>
            <div id="aemo-status-detail" style="font-size: 0.85em; margin-top: 0.3em; opacity: 0.9;"></div>
        </div>
    </article>

    <!-- 5-Minute Detailed Billing Window (Amber Only) -->
    {% if has_amber_token %}
    <article id="five-min-pricing" style="background: var(--ps-surface-elevated); padding: 1.5em; border-left: 4px solid var(--ps-primary);">
        <header style="text-align: center; margin-bottom: 1em;">
            <strong style="font-size: 0.9em; text-transform: uppercase; letter-spacing: 1px;">‚òÄÔ∏è Amber Live 5 Min Price</strong>
            <div style="font-size: 0.75em; opacity: 0.8; margin-top: 0.2em;">
                <span id="price-type-indicator">ActualInterval</span> - Last Completed 5-Min Period
            </div>
            <div id="current-interval-time" style="font-size: 1.1em; font-weight: bold; margin-top: 0.3em;">--:-- - --:--</div>
        </header>
        <div style="display: flex; justify-content: center; gap: 2em; margin-bottom: 1.5em;">
            <div id="import-selector" onclick="selectPriceChannel('general')" class="price-gauge" style="cursor: pointer;">
                <div id="import-circle" class="price-circle import">
                    <div id="current-general-price" class="price-value">--¬¢</div>
                    <div class="price-unit">/kWh</div>
                    <div id="current-renewables" class="price-label">--% renewable</div>
                </div>
                <div class="text-sm text-secondary" style="margin-top: 0.5em;">IMPORT ‚úì</div>
            </div>
            <div id="export-selector" onclick="selectPriceChannel('feedIn')" class="price-gauge" style="cursor: pointer;">
                <div class="price-circle export">
                    <div id="current-feedin-price" class="price-value">--¬¢</div>
                    <div class="price-unit">/kWh</div>
                </div>
                <div class="text-sm text-secondary" style="margin-top: 0.5em;">FEED-IN</div>
            </div>
        </div>
        <!-- 30 Min Forecast - Amber style horizontal scrollable row -->
        <div style="margin-top: 1.5em;">
            <div style="font-size: 0.85em; font-weight: bold; text-align: center; margin-bottom: 0.75em; opacity: 0.9;">30 MIN FORECAST</div>
            <div id="thirty-min-scroll-container" style="overflow-x: auto; padding: 0.5em 0; scroll-behavior: smooth; -webkit-overflow-scrolling: touch;">
                <div id="thirty-min-forecast" style="display: flex; gap: 0.5em; min-width: min-content; padding: 0 1em;">
                    <p style="color: rgba(255,255,255,0.7);">Loading forecast...</p>
                </div>
            </div>
        </div>
    </article>
    {% endif %}

    <!-- Tesla Battery Status -->
    {% if current_user.tesla_energy_site_id %}
    <article id="battery-section">
        <header><strong>Tesla Powerwall Status</strong></header>
        <div id="battery-content">
            <p>Loading battery status...</p>
        </div>
    </article>
    {% endif %}

    <!-- Battery Health & Degradation -->
    <article id="battery-health-section">
        <header>
            <strong>Battery Health</strong>
            <div style="float: right; font-size: 0.85em;">
                <span id="battery-health-last-updated" style="opacity: 0.7;">--</span>
            </div>
        </header>
        <div id="battery-health-content">
            <div id="battery-health-loading">
                <p>Loading battery health data...</p>
            </div>
            <div id="battery-health-no-data" style="display: none; text-align: center; padding: 2em;">
                <p style="opacity: 0.7;">No battery health data available yet.</p>
                <p style="font-size: 0.9em;">Use the <a href="/settings#mobile-app">PowerSync mobile app</a> to scan your Powerwall battery health.</p>
            </div>
            <div id="battery-health-data" style="display: none;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1em; margin-bottom: 1.5em;">
                    <div style="text-align: center; padding: 1em; background: rgba(0, 128, 0, 0.1); border-radius: 8px;">
                        <div style="font-size: 0.85em; opacity: 0.8;">Health</div>
                        <div id="health-percent" style="font-size: 2em; font-weight: bold; color: #22c55e;">--%</div>
                    </div>
                    <div style="text-align: center; padding: 1em; background: rgba(0, 0, 0, 0.05); border-radius: 8px;">
                        <div style="font-size: 0.85em; opacity: 0.8;">Degradation</div>
                        <div id="degradation-percent" style="font-size: 2em; font-weight: bold;">--%</div>
                    </div>
                    <div style="text-align: center; padding: 1em; background: rgba(0, 0, 0, 0.05); border-radius: 8px;">
                        <div style="font-size: 0.85em; opacity: 0.8;">Actual Capacity</div>
                        <div id="actual-capacity" style="font-size: 1.5em; font-weight: bold;">-- kWh</div>
                    </div>
                    <div style="text-align: center; padding: 1em; background: rgba(0, 0, 0, 0.05); border-radius: 8px;">
                        <div style="font-size: 0.85em; opacity: 0.8;">Rated Capacity</div>
                        <div id="rated-capacity" style="font-size: 1.5em; font-weight: bold;">-- kWh</div>
                    </div>
                </div>
                <!-- Install Date (auto-fetched from Tesla API) -->
                <div style="margin-bottom: 1em; padding: 0.75em; background: rgba(0, 0, 0, 0.03); border-radius: 8px;">
                    <div style="display: flex; align-items: center; gap: 0.5em; flex-wrap: wrap;">
                        <span style="font-size: 0.9em; color: var(--muted-color);">Install Date:</span>
                        <span id="install-date-display" style="font-size: 0.9em; font-weight: 500;">Loading...</span>
                        <span style="font-size: 0.75em; color: var(--muted-color);">(from Tesla API)</span>
                    </div>
                </div>
                <!-- Degradation Graph -->
                <details id="degradation-graph-details" open>
                    <summary style="cursor: pointer; font-weight: bold;">Degradation Over Time</summary>
                    <div style="margin-top: 1em;">
                        <canvas id="degradationChart" style="max-height: 300px;"></canvas>
                    </div>
                </details>
            </div>
        </div>
    </article>

    <!-- Tariff Schedule (Amber Only) -->
    {% if has_amber_token %}
    <article id="tou-schedule-section">
        <header>
            <strong>Electricity Tariff Schedule (Rolling 24h)</strong>
            <div style="float: right;">
                <button id="refresh-schedule-btn" style="font-size: 0.9em; margin-right: 0.5em;">Refresh</button>
                {% if current_user.tesla_energy_site_id and (current_user.teslemetry_api_key_encrypted or current_user.tesla_access_token_encrypted) %}
                <button id="toggle-sync-btn" class="{% if current_user.sync_enabled %}secondary{% else %}contrast{% endif %}" style="font-size: 0.9em; margin-right: 0.5em;">
                    Auto-Sync: <span id="sync-status-text">{{ 'ON' if current_user.sync_enabled else 'OFF' }}</span>
                </button>
                <button id="sync-tesla-btn" class="primary" style="font-size: 0.9em;">Sync to Tesla</button>
                {% endif %}
            </div>
        </header>
        <div id="sync-status" style="margin-bottom: 1em;"></div>
        <div id="tou-schedule-content">
            <p>Loading tariff schedule...</p>
        </div>
        <details id="tou-forecast-details" style="margin-top: 1em;">
            <summary>View Buy/Sell Price Chart</summary>
            <canvas id="forecastChart" style="max-height: 300px; margin-top: 1em;"></canvas>
        </details>
    </article>

    <!-- Price History Chart (Amber Only) -->
    <article id="price-history-section">
        <header>
            <strong>Price History</strong>
            <div style="float: right;">
                <select id="price-day-selector" style="font-size: 0.9em;">
                    <!-- Options populated dynamically by JavaScript -->
                </select>
            </div>
        </header>
        <canvas id="priceChart" style="max-height: 300px;"></canvas>
    </article>
    {% endif %}

    <!-- Energy Usage Logging -->
    <article id="energy-usage-section">
        <header>
            <strong>Energy Usage History</strong>
            <div style="float: right;">
                <select id="timeframe-selector" style="font-size: 0.9em;">
                    <option value="day" selected>Day</option>
                    <option value="month">Month</option>
                    <option value="year">Year</option>
                </select>
            </div>
        </header>

        <!-- Energy Charts Grid -->
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1em; margin-top: 1em;">
            <!-- Solar Chart -->
            <div>
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.5em;">
                    <div>
                        <h4 style="margin: 0;">Solar Generation</h4>
                        <div style="font-size: 0.8em; font-weight: normal; color: #666; margin-top: 0.2em;">
                            <span id="solar-current-value">-- W</span>
                        </div>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-size: 1.2em; font-weight: bold; color: #333;">
                            <span id="solar-daily-total">-- kWh</span>
                        </div>
                        <div style="font-size: 0.75em; color: #666;">
                            Generated
                        </div>
                    </div>
                </div>
                <canvas id="solarChart" style="max-height: 200px;"></canvas>
            </div>

            <!-- Grid Chart -->
            <div>
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.5em;">
                    <div>
                        <h4 style="margin: 0;">Grid Power</h4>
                        <div style="font-size: 0.8em; font-weight: normal; color: #666; margin-top: 0.2em;">
                            <span id="grid-current-value">-- W</span>
                        </div>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-size: 1.2em; font-weight: bold; color: #333;">
                            <span id="grid-daily-total">-- kWh</span>
                        </div>
                        <div style="font-size: 0.75em; color: #666;">
                            <span id="grid-daily-label">Net</span>
                        </div>
                    </div>
                </div>
                <canvas id="gridChart" style="max-height: 200px;"></canvas>
            </div>

            <!-- Battery Chart -->
            <div>
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.5em;">
                    <div>
                        <h4 style="margin: 0;">Battery Power</h4>
                        <div style="font-size: 0.8em; font-weight: normal; color: #666; margin-top: 0.2em;">
                            <span id="battery-current-value">-- W</span>
                        </div>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-size: 1.2em; font-weight: bold; color: #333;">
                            <span id="battery-daily-total">-- kWh</span>
                        </div>
                        <div style="font-size: 0.75em; color: #666;">
                            <span id="battery-daily-label">Net</span>
                        </div>
                    </div>
                </div>
                <canvas id="batteryChart" style="max-height: 200px;"></canvas>
            </div>

            <!-- Load Chart -->
            <div>
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.5em;">
                    <div>
                        <h4 style="margin: 0;">Home Load</h4>
                        <div style="font-size: 0.8em; font-weight: normal; color: #666; margin-top: 0.2em;">
                            <span id="load-current-value">-- W</span>
                        </div>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-size: 1.2em; font-weight: bold; color: #333;">
                            <span id="load-daily-total">-- kWh</span>
                        </div>
                        <div style="font-size: 0.75em; color: #666;">
                            Consumed
                        </div>
                    </div>
                </div>
                <canvas id="loadChart" style="max-height: 200px;"></canvas>
            </div>
        </div>
    </article>

    <!-- Energy Summaries (from Tesla Calendar History) -->
    <article id="energy-summaries-section">
        <header>
            <strong>Energy Summaries (Historical Totals)</strong>
            <div style="float: right;">
                <select id="summary-period-selector" style="font-size: 0.9em;">
                    <option value="day">Today</option>
                    <option value="week">This Week</option>
                    <option value="month" selected>This Month</option>
                    <option value="year">This Year</option>
                </select>
                <button id="refresh-summaries-btn" style="font-size: 0.9em; margin-left: 0.5em;">Refresh</button>
            </div>
        </header>
        <div id="energy-summaries-content" style="margin-top: 1em;">
            <p>Loading energy summaries...</p>
        </div>
    </article>

    <!-- Chart.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-crosshair@2.0.0/dist/chartjs-plugin-crosshair.min.js"></script>

    <script>
        // ========================================
        // DISCHARGE CONTROL FUNCTIONS
        // ========================================

        // Show discharge duration modal
        function showDischargeModal() {
            document.getElementById('discharge-modal').showModal();
        }

        // Close discharge modal
        function closeDischargeModal() {
            document.getElementById('discharge-modal').close();
        }

        // Activate force discharge
        async function activateForceDischarge() {
            const duration = document.getElementById('discharge-duration').value;
            const btn = document.getElementById('force-discharge-btn');

            btn.setAttribute('aria-busy', 'true');
            btn.disabled = true;

            try {
                const response = await fetch('/api/force-discharge', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ duration_minutes: parseInt(duration) })
                });

                const result = await response.json();

                if (result.success) {
                    closeDischargeModal();
                    updateDischargeStatus(true, result.expires_at, duration);
                    showNotification('Force discharge activated for ' + duration + ' minutes', 'success');
                } else {
                    showNotification('Error: ' + (result.error || 'Failed to activate discharge'), 'error');
                }
            } catch (error) {
                showNotification('Error: ' + error.message, 'error');
            } finally {
                btn.removeAttribute('aria-busy');
                btn.disabled = false;
            }
        }

        // Restore normal operation
        async function restoreNormal() {
            const btn = document.getElementById('restore-normal-btn');

            btn.setAttribute('aria-busy', 'true');
            btn.disabled = true;

            try {
                const response = await fetch('/api/restore-normal', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                const result = await response.json();

                if (result.success) {
                    updateDischargeStatus(false);
                    showNotification('Normal operation restored', 'success');
                } else {
                    showNotification('Error: ' + (result.error || 'Failed to restore'), 'error');
                }
            } catch (error) {
                showNotification('Error: ' + error.message, 'error');
            } finally {
                btn.removeAttribute('aria-busy');
                btn.disabled = false;
            }
        }

        // Update discharge status display
        function updateDischargeStatus(active, expiresAt, durationMinutes) {
            const statusDiv = document.getElementById('discharge-status');
            const statusText = document.getElementById('discharge-status-text');
            const dischargeBtn = document.getElementById('force-discharge-btn');
            const restoreBtn = document.getElementById('restore-normal-btn');

            if (active) {
                const expiry = new Date(expiresAt);
                const timeStr = expiry.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                statusDiv.style.display = 'block';
                statusDiv.style.background = 'rgba(234, 179, 8, 0.2)';
                statusText.innerHTML = '‚ö° <strong>Force Discharge Active</strong> - Expires at ' + timeStr + ' (' + durationMinutes + ' min)';
                dischargeBtn.classList.remove('contrast');
                dischargeBtn.classList.add('outline');
                dischargeBtn.innerHTML = '‚ö° Discharging...';
            } else {
                statusDiv.style.display = 'none';
                dischargeBtn.classList.remove('outline');
                dischargeBtn.classList.add('contrast');
                dischargeBtn.innerHTML = '‚ö° Force Discharge';
            }
        }

        // Check current discharge status on page load
        async function checkDischargeStatus() {
            try {
                const response = await fetch('/api/discharge-status');
                const status = await response.json();

                if (status.active) {
                    updateDischargeStatus(true, status.expires_at, status.remaining_minutes);
                } else if (status.charge_active) {
                    updateChargeStatus(true, status.charge_expires_at, status.charge_remaining_minutes);
                }
            } catch (error) {
                console.error('Error checking discharge status:', error);
            }
        }

        // ========================================
        // CHARGE CONTROL FUNCTIONS
        // ========================================

        // Show charge duration modal
        function showChargeModal() {
            document.getElementById('charge-modal').showModal();
        }

        // Close charge modal
        function closeChargeModal() {
            document.getElementById('charge-modal').close();
        }

        // Activate force charge
        async function activateForceCharge() {
            const duration = document.getElementById('charge-duration').value;
            const btn = document.getElementById('force-charge-btn');

            btn.setAttribute('aria-busy', 'true');
            btn.disabled = true;

            try {
                const response = await fetch('/api/force-charge', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ duration_minutes: parseInt(duration) })
                });

                const result = await response.json();

                if (result.success) {
                    closeChargeModal();
                    updateChargeStatus(true, result.expires_at, duration);
                    showNotification('Force charge activated for ' + duration + ' minutes', 'success');
                } else {
                    showNotification('Error: ' + (result.error || 'Failed to activate charge'), 'error');
                }
            } catch (error) {
                showNotification('Error: ' + error.message, 'error');
            } finally {
                btn.removeAttribute('aria-busy');
                btn.disabled = false;
            }
        }

        // Update charge status display
        function updateChargeStatus(active, expiresAt, durationMinutes) {
            const statusDiv = document.getElementById('discharge-status');
            const statusText = document.getElementById('discharge-status-text');
            const chargeBtn = document.getElementById('force-charge-btn');
            const dischargeBtn = document.getElementById('force-discharge-btn');

            if (active) {
                const expiry = new Date(expiresAt);
                const timeStr = expiry.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                statusDiv.style.display = 'block';
                statusDiv.style.background = 'rgba(59, 130, 246, 0.2)';
                statusText.innerHTML = 'üîå <strong>Force Charge Active</strong> - Expires at ' + timeStr + ' (' + durationMinutes + ' min)';
                chargeBtn.classList.remove('primary');
                chargeBtn.classList.add('outline');
                chargeBtn.innerHTML = 'üîå Charging...';
                // Reset discharge button state
                dischargeBtn.classList.remove('outline');
                dischargeBtn.classList.add('contrast');
                dischargeBtn.innerHTML = '‚ö° Force Discharge';
            } else {
                statusDiv.style.display = 'none';
                chargeBtn.classList.remove('outline');
                chargeBtn.classList.add('primary');
                chargeBtn.innerHTML = 'üîå Force Charge';
            }
        }

        // Simple notification function
        function showNotification(message, type) {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 1rem;
                right: 1rem;
                padding: 1rem 1.5rem;
                border-radius: 0.5rem;
                color: white;
                font-weight: bold;
                z-index: 9999;
                animation: slideIn 0.3s ease;
                background: ${type === 'success' ? '#22c55e' : '#ef4444'};
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            // Remove after 3 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // Check discharge status on page load
        document.addEventListener('DOMContentLoaded', checkDischargeStatus);

        // ========================================
        // PRICE CHANNEL FUNCTIONS
        // ========================================

        // Track selected price channel (general = import, feedIn = export)
        let selectedChannel = 'general';

        // Function to select price channel and update display
        function selectPriceChannel(channel) {
            selectedChannel = channel;

            // Update visual indicators
            const importSelector = document.getElementById('import-selector');
            const exportSelector = document.getElementById('export-selector');

            if (channel === 'general') {
                // Import selected
                importSelector.querySelector(':scope > div:last-child').innerHTML = 'IMPORT ‚úì';
                exportSelector.querySelector(':scope > div:last-child').innerHTML = 'FEED-IN';
                importSelector.style.transform = 'scale(1.05)';
                exportSelector.style.transform = 'scale(1)';
            } else {
                // Export selected
                importSelector.querySelector(':scope > div:last-child').innerHTML = 'IMPORT';
                exportSelector.querySelector(':scope > div:last-child').innerHTML = 'FEED-IN ‚úì';
                importSelector.style.transform = 'scale(1)';
                exportSelector.style.transform = 'scale(1.05)';
            }

            // Regenerate forecasts with selected channel
            generate5MinForecast();
            generate30MinForecast();
        }

        // Check API status
        async function checkAPIStatus() {
            try {
                const response = await fetch('/api/status');
                const status = await response.json();

                // Update Amber status
                const amberDiv = document.getElementById('amber-status');
                const amberContent = document.getElementById('amber-status-content');
                if (status.amber && status.amber.connected) {
                    amberDiv.style.background = 'rgba(0, 255, 0, 0.1)';
                    amberContent.innerHTML = `
                        <p style="margin: 0; color: var(--ins-color); font-weight: bold;">‚úì Connected</p>
                    `;
                } else {
                    amberDiv.style.background = 'rgba(255, 0, 0, 0.1)';
                    amberContent.innerHTML = `
                        <p style="margin: 0; color: var(--del-color); font-weight: bold;">‚úó Not Connected</p>
                    `;
                }

                // Update Tesla status
                const teslaDiv = document.getElementById('tesla-status');
                const teslaContent = document.getElementById('tesla-status-content');
                if (status.tesla && status.tesla.connected) {
                    teslaDiv.style.background = 'rgba(0, 255, 0, 0.1)';
                    teslaContent.innerHTML = `
                        <p style="margin: 0; color: var(--ins-color); font-weight: bold;">‚úì Connected</p>
                    `;
                } else {
                    teslaDiv.style.background = 'rgba(255, 0, 0, 0.1)';
                    teslaContent.innerHTML = `
                        <p style="margin: 0; color: var(--del-color); font-weight: bold;">‚úó Not Connected</p>
                    `;
                }

                // If Amber is connected, fetch current prices
                if (status.amber.connected) {
                    await fetchCurrentPrices();
                }

                // If Tesla is connected, fetch battery status
                if (status.tesla.connected) {
                    await fetchTeslaStatus();
                }

                // Fetch curtailment status if enabled
                {% if solar_curtailment_enabled %}
                await fetchCurtailmentStatus();
                {% endif %}

                // Fetch AC inverter status if enabled
                {% if inverter_curtailment_enabled %}
                await fetchACInverterStatus();
                {% endif %}

                // Always try to fetch AEMO price (independent of Amber/Tesla)
                await fetchAEMOPrice();
            } catch (error) {
                console.error('Error checking API status:', error);
            }
        }

        // Fetch and display solar curtailment status
        {% if solar_curtailment_enabled %}
        async function fetchCurtailmentStatus() {
            try {
                const response = await fetch('/api/curtailment-status');
                const data = await response.json();

                const curtailmentDiv = document.getElementById('curtailment-status');
                const curtailmentContent = document.getElementById('curtailment-status-content');

                if (!curtailmentDiv || !curtailmentContent) return;

                if (!data.enabled) {
                    curtailmentDiv.style.display = 'none';
                    return;
                }

                if (data.error) {
                    curtailmentDiv.style.background = 'rgba(255, 165, 0, 0.1)';
                    curtailmentContent.innerHTML = `
                        <p style="margin: 0; color: orange; font-weight: bold;">‚ö† ${data.error}</p>
                    `;
                    return;
                }

                if (data.is_curtailed) {
                    // Curtailment is active (export blocked)
                    curtailmentDiv.style.background = 'rgba(255, 0, 0, 0.15)';
                    let priceInfo = '';
                    if (data.export_earnings !== null) {
                        priceInfo = `<br><span style="font-size: 0.75em; opacity: 0.8;">Earnings: ${data.export_earnings.toFixed(1)}¬¢/kWh</span>`;
                    }
                    curtailmentContent.innerHTML = `
                        <p style="margin: 0; color: var(--del-color); font-weight: bold;">üö´ Export Blocked</p>
                        <p style="margin: 0.2em 0 0 0; font-size: 0.75em;">Rule: ${data.export_rule || 'never'}${priceInfo}</p>
                    `;
                } else {
                    // Normal operation (exporting allowed)
                    curtailmentDiv.style.background = 'rgba(0, 255, 0, 0.1)';
                    let priceInfo = '';
                    if (data.export_earnings !== null) {
                        priceInfo = `<br><span style="font-size: 0.75em; opacity: 0.8;">Earnings: ${data.export_earnings.toFixed(1)}¬¢/kWh</span>`;
                    }
                    curtailmentContent.innerHTML = `
                        <p style="margin: 0; color: var(--ins-color); font-weight: bold;">‚úì Exporting</p>
                        <p style="margin: 0.2em 0 0 0; font-size: 0.75em;">Rule: ${data.export_rule || 'battery_ok'}${priceInfo}</p>
                    `;
                }
            } catch (error) {
                console.error('Error fetching curtailment status:', error);
            }
        }
        {% endif %}

        // Fetch and display AC inverter status
        {% if inverter_curtailment_enabled %}
        async function fetchACInverterStatus() {
            try {
                const response = await fetch('/api/inverter/status');
                const data = await response.json();

                const inverterDiv = document.getElementById('ac-inverter-status');
                const inverterContent = document.getElementById('ac-inverter-status-content');

                if (!inverterDiv || !inverterContent) return;

                if (data.error) {
                    inverterDiv.style.background = 'rgba(255, 165, 0, 0.1)';
                    inverterContent.innerHTML = `
                        <p style="margin: 0; color: orange; font-weight: bold;">‚ö† ${data.error}</p>
                    `;
                    return;
                }

                const status = data.status || 'unknown';
                const powerW = data.power_output_w;
                const powerStr = powerW !== null ? `${(powerW / 1000).toFixed(1)}kW` : '';

                if (status === 'sleep') {
                    inverterDiv.style.background = 'rgba(96, 125, 139, 0.15)';
                    inverterContent.innerHTML = `
                        <p style="margin: 0; color: #607D8B; font-weight: bold;">üåô Sleep</p>
                        <p style="margin: 0.2em 0 0 0; font-size: 0.75em;">${data.brand || 'Inverter'} - Nighttime</p>
                    `;
                } else if (status === 'curtailed' || data.is_curtailed) {
                    inverterDiv.style.background = 'rgba(255, 0, 0, 0.15)';
                    inverterContent.innerHTML = `
                        <p style="margin: 0; color: var(--del-color); font-weight: bold;">üö´ Curtailed</p>
                        <p style="margin: 0.2em 0 0 0; font-size: 0.75em;">${data.brand || 'Inverter'} - ${data.power_limit_percent || 0}%</p>
                    `;
                } else if (status === 'offline' || status === 'error') {
                    inverterDiv.style.background = 'rgba(255, 165, 0, 0.1)';
                    inverterContent.innerHTML = `
                        <p style="margin: 0; color: orange; font-weight: bold;">‚ö† Offline</p>
                        <p style="margin: 0.2em 0 0 0; font-size: 0.75em;">${data.error_message || 'Cannot reach inverter'}</p>
                    `;
                } else {
                    // Online/running
                    inverterDiv.style.background = 'rgba(0, 255, 0, 0.1)';
                    inverterContent.innerHTML = `
                        <p style="margin: 0; color: var(--ins-color); font-weight: bold;">‚úì Online</p>
                        <p style="margin: 0.2em 0 0 0; font-size: 0.75em;">${data.brand || 'Inverter'}${powerStr ? ' - ' + powerStr : ''}</p>
                    `;
                }
            } catch (error) {
                console.error('Error fetching AC inverter status:', error);
            }
        }
        {% endif %}

        // Fetch and display AEMO wholesale price
        async function fetchAEMOPrice() {
            try {
                const response = await fetch('/api/aemo-price');
                const data = await response.json();

                const monitor = document.getElementById('aemo-price-monitor');

                if (!data.enabled) {
                    // AEMO not enabled - hide the monitor
                    monitor.style.display = 'none';
                    return;
                }

                if (data.error) {
                    // Error fetching - show but indicate error
                    monitor.style.display = 'block';
                    document.getElementById('aemo-current-price').textContent = 'Error';
                    document.getElementById('aemo-status-text').textContent = data.error;
                    return;
                }

                // Show the monitor
                monitor.style.display = 'block';

                // Update region
                document.getElementById('aemo-region').textContent = data.region + ' Region';

                // Update current price
                const priceElement = document.getElementById('aemo-current-price');
                priceElement.textContent = '$' + data.current_price.toFixed(0);

                // Update threshold
                document.getElementById('aemo-threshold').textContent = '$' + data.threshold.toFixed(0);

                // Update status indicator and color
                const statusIndicator = document.getElementById('aemo-status-indicator');
                const statusText = document.getElementById('aemo-status-text');
                const statusDetail = document.getElementById('aemo-status-detail');
                const priceDisplay = document.getElementById('aemo-price-display');
                const monitorArticle = document.getElementById('aemo-price-monitor');

                if (data.in_spike_mode) {
                    // SPIKE MODE - Red alert
                    statusText.textContent = 'üö® SPIKE MODE ACTIVE';
                    statusDetail.textContent = 'Powerwall exporting to grid at high rates';
                    statusIndicator.style.background = 'rgba(220, 38, 38, 0.3)';
                    statusIndicator.style.border = '2px solid rgba(220, 38, 38, 0.6)';
                    priceDisplay.style.background = 'rgba(220, 38, 38, 0.25)';
                    monitorArticle.style.background = 'linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%)';
                } else if (data.is_spike) {
                    // Above threshold but not yet in spike mode
                    statusText.textContent = '‚ö†Ô∏è PRICE SPIKE DETECTED';
                    statusDetail.textContent = 'Entering spike mode...';
                    statusIndicator.style.background = 'rgba(245, 158, 11, 0.3)';
                    statusIndicator.style.border = '2px solid rgba(245, 158, 11, 0.6)';
                    priceDisplay.style.background = 'rgba(245, 158, 11, 0.25)';
                    monitorArticle.style.background = 'linear-gradient(135deg, #92400e 0%, #b45309 100%)';
                } else {
                    // Normal pricing
                    statusText.textContent = '‚úì Normal Pricing';
                    statusDetail.textContent = 'Price below threshold - standard operation';
                    statusIndicator.style.background = 'rgba(255, 255, 255, 0.1)';
                    statusIndicator.style.border = 'none';
                    priceDisplay.style.background = 'rgba(255, 255, 255, 0.15)';
                    monitorArticle.style.background = 'linear-gradient(135deg, #065f46 0%, #047857 100%)';
                }

            } catch (error) {
                console.error('Error fetching AEMO price:', error);
                // Hide on error
                document.getElementById('aemo-price-monitor').style.display = 'none';
            }
        }

        // Update 5-minute billing window
        function update5MinWindow(prices) {
            // Find current general and feedin prices
            const generalPrice = prices.find(p => p.channelType === 'general');
            const feedinPrice = prices.find(p => p.channelType === 'feedIn');

            if (generalPrice) {
                // Update price type indicator based on interval type
                const priceTypeIndicator = document.getElementById('price-type-indicator');
                if (generalPrice.type === 'ActualInterval') {
                    priceTypeIndicator.textContent = 'ActualInterval';
                    priceTypeIndicator.style.color = '#22c55e'; // Green for actual
                } else {
                    priceTypeIndicator.textContent = 'CurrentInterval';
                    priceTypeIndicator.style.color = '#fbbf24'; // Yellow for current (weighted avg)
                }

                // Use backend-provided display times (already formatted in user's timezone)
                if (generalPrice.displayIntervalStart && generalPrice.displayIntervalEnd) {
                    document.getElementById('current-interval-time').textContent =
                        `${generalPrice.displayIntervalStart} - ${generalPrice.displayIntervalEnd}`;
                } else {
                    // Fallback: calculate from current browser time (if backend doesn't provide display times)
                    const now = new Date();
                    const currentMinute = now.getMinutes();
                    const intervalStart = Math.floor(currentMinute / 5) * 5;
                    const intervalEnd = intervalStart + 5;
                    const startTime = `${String(now.getHours()).padStart(2, '0')}:${String(intervalStart).padStart(2, '0')}`;
                    const endTime = `${String(now.getHours()).padStart(2, '0')}:${String(intervalEnd).padStart(2, '0')}`;
                    document.getElementById('current-interval-time').textContent = `${startTime} - ${endTime}`;
                }

                document.getElementById('current-general-price').textContent = `${Math.abs(generalPrice.perKwh).toFixed(0)}¬¢`;
                document.getElementById('current-renewables').textContent = `${Math.round(generalPrice.renewables || 0)}% renewable`;

                // Update import circle color to match current tile color
                const absPrice = Math.abs(generalPrice.perKwh);
                let circleColor;
                if (absPrice < 20) {
                    circleColor = '#22c55e'; // green (<20¬¢)
                } else if (absPrice < 30) {
                    circleColor = '#fbbf24'; // yellow (20-30¬¢)
                } else if (absPrice < 40) {
                    circleColor = '#f59e0b'; // medium orange (30-40¬¢)
                } else if (absPrice < 50) {
                    circleColor = '#f97316'; // dark orange (40-50¬¢)
                } else {
                    circleColor = '#ef4444'; // red (‚â•50¬¢)
                }
                document.getElementById('import-circle').style.background = circleColor;
            }

            if (feedinPrice) {
                // Amber returns feed-in as: negative = you get paid, positive = you pay
                // Negate for display so positive = earnings (what user expects)
                const feedinValue = -feedinPrice.perKwh;
                const feedinPriceEl = document.getElementById('current-feedin-price');
                feedinPriceEl.textContent = `${feedinValue.toFixed(0)}¬¢`;
                // Red text for negative prices (you pay to export)
                feedinPriceEl.style.color = feedinValue < 0 ? '#ef4444' : '';
            }

            // Fetch and display 5-minute forecast (separate API call)
            // Pass live WebSocket prices for the current tile
            generate5MinForecast(generalPrice, feedinPrice);
        }

        // Fetch and display real 5-minute interval forecast from Amber API
        // Shows current 30-min period (from now) + next 30-min period
        // Uses live WebSocket price for current tile, forecast prices for future tiles
        async function generate5MinForecast(liveGeneralPrice, liveFeedinPrice) {
            const forecastDiv = document.getElementById('five-min-forecast');
            // Skip if the element doesn't exist (replaced by 30-min forecast)
            if (!forecastDiv) return;

            try {
                // Fetch 5-minute interval data from API
                const response = await fetch('/api/amber/5min-forecast');
                if (!response.ok) {
                    forecastDiv.innerHTML = '<p style="color: rgba(255,255,255,0.7);">5-minute forecast not available</p>';
                    return;
                }

                const data = await response.json();
                const generalIntervals = data.general || [];
                const feedinIntervals = data.feedIn || [];
                const forecastType = data.forecast_type || 'predicted';

                // Helper function to get the correct price from an interval
                // Uses advancedPrice[forecast_type] for ForecastInterval, falls back to perKwh
                function getDisplayPrice(interval) {
                    if (interval.advancedPrice && interval.advancedPrice[forecastType] !== undefined) {
                        return interval.advancedPrice[forecastType];
                    }
                    return interval.perKwh;
                }

                // Select intervals based on selected channel
                const sourceIntervals = selectedChannel === 'general' ? generalIntervals : feedinIntervals;

                if (sourceIntervals.length === 0) {
                    forecastDiv.innerHTML = '<p style="color: rgba(255,255,255,0.7);">No forecast data available</p>';
                    return;
                }

                // Get current 5-minute interval and 30-minute period from backend-provided time (user's timezone)
                let currentHour, currentMinute;
                if (liveGeneralPrice && liveGeneralPrice.displayIntervalStart) {
                    // Parse "HH:MM" format from backend
                    const [hour, minute] = liveGeneralPrice.displayIntervalStart.split(':').map(Number);
                    currentHour = hour;
                    currentMinute = minute;
                } else {
                    // Fallback to browser time (less accurate due to timezone differences)
                    const now = new Date();
                    currentHour = now.getHours();
                    currentMinute = Math.floor(now.getMinutes() / 5) * 5;
                }
                const current30MinPeriod = Math.floor(currentMinute / 30) * 30; // 0 or 30

                // Calculate end of current 30-min period and end of next 30-min period
                const currentPeriodEnd = current30MinPeriod + 30;
                const nextPeriodEnd = currentPeriodEnd + 30;

                // Filter intervals: from current interval to end of next 30-min period
                const filteredIntervals = sourceIntervals.filter(interval => {
                    // Use backend-provided localHour and localMinute (already converted to user's timezone)
                    const hour = interval.localHour;
                    const minute = interval.localMinute;

                    // Same hour, minute >= current minute, minute < next period end
                    if (hour === currentHour) {
                        if (nextPeriodEnd <= 60) {
                            // Next period doesn't cross hour boundary
                            return minute >= currentMinute && minute < nextPeriodEnd;
                        } else {
                            // Next period crosses hour boundary
                            return minute >= currentMinute;
                        }
                    }

                    // Next hour (if next period crosses hour boundary)
                    if (nextPeriodEnd > 60 && hour === (currentHour + 1) % 24) {
                        return minute < (nextPeriodEnd - 60);
                    }

                    return false;
                });

                // Don't update the big circles here - they're updated by update5MinWindow() with live WebSocket prices
                // The big circles should always show the most accurate real-time price, not forecast data

                // Generate HTML for individual 5-minute slots (matching Amber app)
                let html = '';

                filteredIntervals.forEach((interval, idx) => {
                    // Use backend-provided localHour and localMinute (already converted to user's timezone)
                    const hour = interval.localHour;
                    const minute = interval.localMinute;
                    const timeLabel = `${hour}:${String(minute).padStart(2, '0')}`;

                    // Check if this is the current 5-minute interval
                    // Use both time match AND first tile (idx === 0) as fallback for current detection
                    const isCurrent = (hour === currentHour && minute === currentMinute) || idx === 0;

                    // Use live WebSocket price for current tile, forecast price for future tiles
                    let displayInterval = interval;
                    if (isCurrent) {
                        // Override with live WebSocket price for the current interval
                        const livePrice = selectedChannel === 'general' ? liveGeneralPrice : liveFeedinPrice;
                        if (livePrice) {
                            displayInterval = livePrice;
                        }
                    }

                    // Determine circle color based on price and channel type
                    let circleColor;
                    const absPrice = Math.abs(getDisplayPrice(displayInterval));

                    if (selectedChannel === 'general') {
                        // Import prices - 4-color scale (green/yellow/orange/red)
                        if (absPrice < 20) {
                            circleColor = '#22c55e'; // green (<20¬¢)
                        } else if (absPrice < 30) {
                            circleColor = '#fbbf24'; // yellow (20-30¬¢)
                        } else if (absPrice < 40) {
                            circleColor = '#f59e0b'; // medium orange (30-40¬¢)
                        } else if (absPrice < 50) {
                            circleColor = '#f97316'; // dark orange (40-50¬¢)
                        } else {
                            circleColor = '#ef4444'; // red (‚â•50¬¢)
                        }
                    } else {
                        // Export prices - yellow scale (all yellow dots)
                        circleColor = '#fbbf24'; // yellow (default)
                        if (absPrice < 5) {
                            circleColor = '#fde047'; // lighter yellow (very low)
                        } else if (absPrice >= 10) {
                            circleColor = '#f59e0b'; // darker yellow/amber (high)
                        }
                    }

                    // Border style: colored for current, subtle for others
                    const borderColor = selectedChannel === 'general' ? '#f97316' : '#fbbf24';
                    const borderStyle = isCurrent ? `3px solid ${borderColor}` : '1px solid rgba(255,255,255,0.15)';
                    const bgStyle = isCurrent ? (selectedChannel === 'general' ? 'rgba(249, 115, 22, 0.1)' : 'rgba(251, 191, 36, 0.1)') : 'rgba(255,255,255,0.03)';

                    // For current tile, use perKwh directly to match main circle; for forecast tiles use getDisplayPrice
                    let displayPrice;
                    if (selectedChannel === 'general') {
                        // Import: use perKwh for current tile (matches main circle), advancedPrice for forecast
                        displayPrice = isCurrent ? Math.abs(displayInterval.perKwh) : absPrice;
                    } else {
                        // Feed-in: negate and use perKwh for current tile (matches main circle), advancedPrice for forecast
                        displayPrice = isCurrent ? -displayInterval.perKwh : -getDisplayPrice(displayInterval);
                    }

                    // Red text for negative feed-in prices (you pay to export)
                    const priceColor = (selectedChannel !== 'general' && displayPrice < 0) ? '#ef4444' : '';

                    html += `
                        <div style="border: ${borderStyle}; border-radius: 12px; padding: 0.7em; min-width: 70px; background: ${bgStyle}; text-align: center;">
                            <div style="font-size: 0.75em; font-weight: ${isCurrent ? 'bold' : 'normal'}; margin-bottom: 0.4em; opacity: 0.9;">${timeLabel}</div>
                            <div style="color: ${circleColor}; font-size: 2.5em; line-height: 1;">‚óè</div>
                            <div style="font-size: 1em; font-weight: bold; margin-top: 0.3em;${priceColor ? ` color: ${priceColor};` : ''}">${displayPrice.toFixed(0)}¬¢</div>
                            <div style="font-size: 0.75em; opacity: 0.7; margin-top: 0.2em;">${Math.round(displayInterval.renewables || 0)}%</div>
                        </div>
                    `;
                });

                forecastDiv.innerHTML = html;

            } catch (error) {
                console.error('Error fetching 5-min forecast:', error);
                forecastDiv.innerHTML = '<p style="color: rgba(255,255,255,0.7);">Error loading forecast</p>';
            }
        }

        // Amber-style 30-min forecast - horizontal scrollable row with inline expandable blocks
        // Current block is always centered, past blocks are greyed out
        // Only current and next block are expandable (API only has accurate 5-min data for these)
        let currentExpandedBlock = null;
        let thirtyMinBlocksData = []; // Store block data for expansion
        let initialExpandDone = false; // Track if we've done the initial auto-expand

        // Store 5-min data for block expansion (fetched separately)
        let fiveMinIntervalsCache = { general: [], feedIn: [] };
        // Cache for 30-min data to avoid re-fetching on toggle
        let thirtyMinDataCache = { general: [], feedIn: [], forecastType: 'predicted' };

        // Fetch forecast data (called periodically, not on toggle)
        async function fetch30MinForecastData() {
            try {
                // Fetch both 30-min and 5-min data in parallel
                const [response30min, response5min] = await Promise.all([
                    fetch('/api/amber/30min-forecast?hours=24'),
                    fetch('/api/amber/5min-forecast?hours=1')
                ]);

                if (response30min.ok) {
                    const data = await response30min.json();
                    thirtyMinDataCache = {
                        general: data.general || [],
                        feedIn: data.feedIn || [],
                        forecastType: data.forecast_type || 'predicted'
                    };
                }

                if (response5min.ok) {
                    const data5min = await response5min.json();
                    fiveMinIntervalsCache = {
                        general: data5min.general || [],
                        feedIn: data5min.feedIn || []
                    };
                }

                return true;
            } catch (error) {
                console.error('Error fetching forecast data:', error);
                return false;
            }
        }

        // Render the 30-min forecast from cached data (fast, no network)
        function render30MinForecast() {
            const forecastDiv = document.getElementById('thirty-min-forecast');
            const scrollContainer = document.getElementById('thirty-min-scroll-container');
            if (!forecastDiv) return;

            const forecastType = thirtyMinDataCache.forecastType;

            // Select intervals based on selected channel
            const sourceIntervals = selectedChannel === 'general' ? thirtyMinDataCache.general : thirtyMinDataCache.feedIn;

            if (sourceIntervals.length === 0) {
                forecastDiv.innerHTML = '<p style="color: rgba(255,255,255,0.7);">No forecast data available</p>';
                return;
            }

            // Get current time
            const now = new Date();
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            const current30Min = Math.floor(currentMinute / 30) * 30;

            // Helper to get price from interval
            function getDisplayPrice(interval) {
                if (interval.advancedPrice && interval.advancedPrice[forecastType] !== undefined) {
                    return interval.advancedPrice[forecastType];
                }
                return interval.perKwh;
            }

            // Helper to determine spike status
            function getSpikeInfo(intervals) {
                let hasSpike = false;
                let hasPotential = false;
                intervals.forEach(interval => {
                    const status = interval.spikeStatus || 'none';
                    if (status === 'spike') hasSpike = true;
                    if (status === 'potential') hasPotential = true;
                });
                if (hasSpike) {
                    return { label: 'Spike', bgColor: 'rgba(220, 38, 38, 0.3)', borderColor: '#ef4444', dotColor: '#ef4444', icon: '‚ö†Ô∏è' };
                } else if (hasPotential) {
                    return { label: 'Spike Risk', bgColor: 'rgba(245, 158, 11, 0.2)', borderColor: '#f59e0b', dotColor: '#f59e0b', icon: '‚ö†Ô∏è' };
                }
                return null;
            }

            // Helper to get price color
            function getPriceColor(price, isGeneral) {
                const absPrice = Math.abs(price);
                if (isGeneral) {
                    if (absPrice < 20) return '#22c55e';
                    if (absPrice < 30) return '#fbbf24';
                    if (absPrice < 40) return '#f59e0b';
                    if (absPrice < 50) return '#f97316';
                    return '#ef4444';
                } else {
                    if (absPrice < 5) return '#fde047';
                    if (absPrice >= 10) return '#f59e0b';
                    return '#fbbf24';
                }
            }

            // Group intervals into 30-min blocks
            // With 30-min resolution, each interval already represents a 30-min period
            // (each block will have exactly 1 interval)
            const blocks = [];
            let currentBlock = null;
            let currentBlockIndex = 0;

            sourceIntervals.forEach((interval, idx) => {
                // Use server-provided localHour/localMinute (based on Powerwall timezone)
                let hour = interval.localHour;
                let minute = interval.localMinute;

                // Fallback: parse from localTime string if localHour/localMinute not set
                if (hour === undefined || minute === undefined) {
                    if (interval.localTime) {
                        const timeParts = interval.localTime.split('T')[1];
                        if (timeParts) {
                            const [h, m] = timeParts.split(':');
                            hour = parseInt(h, 10);
                            minute = parseInt(m, 10);
                        }
                    }
                }

                // Skip if we still can't determine time
                if (hour === undefined || minute === undefined || isNaN(hour) || isNaN(minute)) {
                    console.warn('Could not determine time for interval:', interval);
                    return;
                }

                const block30Min = Math.floor(minute / 30) * 30;

                if (currentBlock === null || hour !== currentBlock.hour || block30Min !== currentBlock.startMinute) {
                    if (currentBlock) blocks.push(currentBlock);
                    currentBlock = {
                        hour: hour,
                        startMinute: block30Min,
                        intervals: [],
                        isCurrent: false,
                        blockIndex: blocks.length
                    };
                }
                // Store parsed hour/minute on interval for later use
                interval.localHour = hour;
                interval.localMinute = minute;
                currentBlock.intervals.push(interval);
            });
            if (currentBlock) blocks.push(currentBlock);

            // The first block from the API is always the current block (it's forecast data)
            // Mark it as current and set currentBlockIndex to 0
            if (blocks.length > 0) {
                blocks[0].isCurrent = true;
                currentBlockIndex = 0;
            }

            // Store for expansion
            // isPast: only blocks before index 0 are past (none from the API since it starts at current)
            // First 2 blocks are expandable if we have 5-min data cached for them
            thirtyMinBlocksData = blocks.map((block, idx) => ({
                ...block,
                forecastType,
                isExpandable: idx === 0 || idx === 1, // First two blocks can be expanded with 5-min data
                isPast: false // No 30-min blocks are past since API starts at current interval
            }));

            // Generate HTML for 30-min blocks - when expanded, show 5-min segments inline in the row
            let html = '';

            blocks.forEach((block, blockIdx) => {
                    const blockId = `block-${blockIdx}`;
                    const blockData = thirtyMinBlocksData[blockIdx];
                    const isExpandable = blockData.isExpandable;
                    const isPast = blockData.isPast;
                    const isCurrent = block.isCurrent;
                    const isExpanded = currentExpandedBlock === blockIdx;

                    // Check for spike status
                    const spikeInfo = getSpikeInfo(block.intervals);

                    if (isExpanded && isExpandable) {
                        // Get 5-min intervals from cache for this 30-min block
                        const cached5min = selectedChannel === 'general' ? fiveMinIntervalsCache.general : fiveMinIntervalsCache.feedIn;
                        // Filter to intervals that fall within this block's 30-min period
                        const blockStart = block.startMinute;
                        const blockEnd = blockStart + 30;
                        const fiveMinIntervals = cached5min.filter(interval => {
                            return interval.localHour === block.hour &&
                                   interval.localMinute >= blockStart &&
                                   interval.localMinute < blockEnd;
                        });

                        // If no 5-min data available, show a message
                        if (fiveMinIntervals.length === 0) {
                            html += `
                                <div id="${blockId}" class="thirty-min-block expanded" data-block-idx="${blockIdx}"
                                    onclick="toggle30MinBlock(${blockIdx})"
                                    style="display: flex; gap: 0.3em; padding: 0.6em 1em; border-radius: 10px; border: 2px solid rgba(255,255,255,0.5); background: rgba(255,255,255,0.1); cursor: pointer; flex-shrink: 0; align-items: center;">
                                    <span style="font-size: 0.75em; opacity: 0.7;">5-min data not available</span>
                                </div>
                            `;
                        } else {
                            // Show individual 5-min segments inline in the row (wrapped in a container with border)
                            const segmentsHtml = fiveMinIntervals.map((interval, iIdx) => {
                                const intPrice = selectedChannel === 'general' ? getDisplayPrice(interval) : -getDisplayPrice(interval);
                                const intColor = getPriceColor(intPrice, selectedChannel === 'general');
                                const intSpike = interval.spikeStatus || 'none';
                                const intIsPast = interval.localHour < currentHour ||
                                    (interval.localHour === currentHour && interval.localMinute < currentMinute);
                                const intOpacity = intIsPast ? '0.5' : '1';
                                const intBg = intSpike === 'spike' ? 'rgba(220, 38, 38, 0.3)' :
                                    intSpike === 'potential' ? 'rgba(245, 158, 11, 0.2)' :
                                    'rgba(255,255,255,0.08)';

                                return `
                                    <div style="padding: 0.4em 0.5em; border-radius: 6px; text-align: center; min-width: 42px; background: ${intBg}; opacity: ${intOpacity}; flex-shrink: 0;">
                                        <div style="font-size: 0.65em; opacity: 0.8;">:${String(interval.localMinute).padStart(2, '0')}</div>
                                        <div style="color: ${intColor}; font-size: 1.3em; line-height: 1;">‚óè</div>
                                        <div style="font-size: 0.75em; font-weight: bold;${selectedChannel !== 'general' && intPrice < 0 ? ' color: #ef4444;' : ''}">${intPrice.toFixed(0)}¬¢</div>
                                    </div>
                                `;
                            }).join('');

                            // Wrap expanded segments in a bordered container
                            html += `
                                <div id="${blockId}" class="thirty-min-block expanded" data-block-idx="${blockIdx}"
                                    onclick="toggle30MinBlock(${blockIdx})"
                                    style="display: flex; gap: 0.3em; padding: 0.4em; border-radius: 10px; border: 2px solid rgba(255,255,255,0.5); background: rgba(255,255,255,0.1); cursor: pointer; flex-shrink: 0;">
                                    ${segmentsHtml}
                                </div>
                            `;
                        }
                    } else {
                        // Show collapsed 30-min block
                        const displayHour = block.hour % 12 || 12;
                        const ampm = block.hour < 12 ? 'am' : 'pm';
                        const timeLabel = `${displayHour}:${String(block.startMinute).padStart(2, '0')}${ampm}`;

                        const prices = block.intervals.map(i => selectedChannel === 'general' ? getDisplayPrice(i) : -getDisplayPrice(i));
                        const avgPrice = prices.reduce((a, b) => a + b, 0) / prices.length;
                        const avgRenewables = block.intervals.reduce((a, i) => a + (i.renewables || 0), 0) / block.intervals.length;

                        const opacity = isPast ? '0.5' : '1';
                        const blockBg = spikeInfo ? spikeInfo.bgColor : 'rgba(255,255,255,0.05)';
                        const blockBorder = spikeInfo ? `2px solid ${spikeInfo.borderColor}` : '1px solid rgba(255,255,255,0.1)';
                        const dotColor = spikeInfo ? spikeInfo.dotColor : getPriceColor(avgPrice, selectedChannel === 'general');
                        const textWeight = isCurrent ? 'bold' : 'normal';
                        const textColor = isCurrent ? '#22c55e' : 'inherit';
                        const cursor = isExpandable ? 'pointer' : 'default';

                        html += `
                            <div id="${blockId}" class="thirty-min-block" data-block-idx="${blockIdx}" style="
                                background: ${blockBg};
                                border: ${blockBorder};
                                border-radius: 10px;
                                padding: 0.5em 0.6em;
                                min-width: 65px;
                                text-align: center;
                                cursor: ${cursor};
                                transition: all 0.2s;
                                flex-shrink: 0;
                                opacity: ${opacity};
                            " ${isExpandable ? `onclick="toggle30MinBlock(${blockIdx})"` : ''}>
                                ${spikeInfo ? `<div style="font-size: 0.55em; color: ${spikeInfo.borderColor}; font-weight: bold;">${spikeInfo.icon} ${spikeInfo.label}</div>` : ''}
                                <div style="font-size: 0.7em; font-weight: ${textWeight}; color: ${textColor};">${timeLabel}</div>
                                <div style="color: ${dotColor}; font-size: 1.5em; line-height: 1; margin: 0.1em 0;">‚óè</div>
                                <div style="font-size: 0.85em; font-weight: ${textWeight};${selectedChannel !== 'general' && avgPrice < 0 ? ' color: #ef4444;' : ''}">${avgPrice.toFixed(0)}¬¢</div>
                                <div style="font-size: 0.55em; opacity: 0.7;">${Math.round(avgRenewables)}%</div>
                                ${isExpandable ? '<div style="font-size: 0.5em; opacity: 0.5; margin-top: 0.1em;">‚ñº</div>' : ''}
                            </div>
                        `;
                    }
                });

                forecastDiv.innerHTML = html;

                // Center scroll on current block (or expanded block) after rendering
                // Use requestAnimationFrame to ensure DOM is fully rendered
                requestAnimationFrame(() => {
                    setTimeout(() => {
                        const targetBlockIdx = currentExpandedBlock !== null ? currentExpandedBlock : currentBlockIndex;
                        const targetBlockEl = document.getElementById(`block-${targetBlockIdx}`);
                        if (targetBlockEl && scrollContainer) {
                            const containerWidth = scrollContainer.offsetWidth;
                            const blockLeft = targetBlockEl.offsetLeft;
                            const blockWidth = targetBlockEl.offsetWidth;
                            const scrollTo = blockLeft - (containerWidth / 2) + (blockWidth / 2);
                            scrollContainer.scrollLeft = scrollTo;
                        }
                    }, 10);
                });

            // No auto-expand - blocks are closed by default
        }

        // Main function: fetch data then render (called on load and periodically)
        async function generate30MinForecast() {
            const forecastDiv = document.getElementById('thirty-min-forecast');
            if (!forecastDiv) return;

            // Show loading state only if no cached data
            if (thirtyMinDataCache.general.length === 0 && thirtyMinDataCache.feedIn.length === 0) {
                forecastDiv.innerHTML = '<p style="color: rgba(255,255,255,0.7);">Loading forecast...</p>';
            }

            // Fetch fresh data
            const success = await fetch30MinForecastData();
            if (!success && thirtyMinDataCache.general.length === 0) {
                forecastDiv.innerHTML = '<p style="color: rgba(255,255,255,0.7);">Failed to load forecast</p>';
                return;
            }

            // Render from cache
            render30MinForecast();
        }

        // Toggle 30-min block expansion - inline, only one at a time
        // Uses cached data - instant response, no network call
        function toggle30MinBlock(blockIdx) {
            // Only current and next block are expandable
            if (!thirtyMinBlocksData[blockIdx] || !thirtyMinBlocksData[blockIdx].isExpandable) return;

            // If clicking the already expanded block, collapse it
            if (currentExpandedBlock === blockIdx) {
                currentExpandedBlock = null;
            } else {
                currentExpandedBlock = blockIdx;
            }

            // Re-render from cache (instant, no network call)
            render30MinForecast();
        }

        // Fetch current electricity prices (Amber or AEMO depending on user config)
        async function fetchCurrentPrices() {
            try {
                const response = await fetch('/api/current-price');
                if (!response.ok) {
                    // Don't spam console if price source isn't configured
                    if (response.status !== 404 && response.status !== 500) {
                        console.error('Failed to fetch prices:', response.status);
                    }
                    return;
                }
                const data = await response.json();

                // Update price source indicator if AEMO
                const priceSourceEl = document.getElementById('price-source-indicator');
                if (priceSourceEl) {
                    priceSourceEl.textContent = data.source || 'Amber';
                }

                // Update 5-minute billing window with live prices
                update5MinWindow(data.prices || data);
            } catch (error) {
                console.error('Error fetching current prices:', error);
            }
        }

        // Fetch Tesla battery status
        async function fetchTeslaStatus() {
            try {
                const response = await fetch('/api/tesla/status');
                if (!response.ok) {
                    throw new Error('Failed to fetch Tesla status');
                }
                const status = await response.json();

                const batteryContent = document.getElementById('battery-content');
                const batteryLevel = status.percentage_charged || 0;
                const batteryColor = batteryLevel > 80 ? 'green' :
                                    batteryLevel > 50 ? 'orange' : 'red';

                // Extract firmware version
                const firmwareVersion = status.firmware_version || 'Unknown';

                batteryContent.innerHTML = `
                    <div class="grid">
                        <div style="text-align: center;">
                            <p style="font-size: 3em; margin: 0; color: ${batteryColor};">
                                <strong>${batteryLevel.toFixed(0)}%</strong>
                            </p>
                            <p style="margin: 0.5em 0 0 0; color: #888;">Battery Level</p>
                        </div>
                        <div>
                            <p style="margin: 0.5em 0;"><strong>Solar:</strong> ${(status.solar_power / 1000).toFixed(2)} kW</p>
                            <p style="margin: 0.5em 0;"><strong>Battery:</strong> ${(status.battery_power / 1000).toFixed(2)} kW</p>
                            <p style="margin: 0.5em 0;"><strong>Grid:</strong> ${(status.grid_power / 1000).toFixed(2)} kW</p>
                            <p style="margin: 0.5em 0; padding-top: 0.5em; border-top: 1px solid rgba(255,255,255,0.1);"><strong>Firmware:</strong> <span style="font-family: monospace;">${firmwareVersion}</span></p>
                        </div>
                    </div>
                `;
            } catch (error) {
                console.error('Error fetching Tesla status:', error);
                document.getElementById('battery-content').innerHTML =
                    '<p style="color: red;">Error loading battery status.</p>';
            }
        }

        // Fetch and display price history chart
        let priceChart = null;
        async function fetchPriceHistory() {
            try {
                const day = document.getElementById('price-day-selector').value;
                const response = await fetch(`/api/price-history?day=${day}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch price history');
                }
                const history = await response.json();

                if ((history.import && history.import.length === 0) && (history.export && history.export.length === 0)) {
                    return;
                }

                const ctx = document.getElementById('priceChart').getContext('2d');

                // Destroy existing chart if it exists
                if (priceChart) {
                    priceChart.destroy();
                }

                // Get metadata for midnight-to-midnight display
                const metadata = history.metadata || null;

                // Process import prices (buy prices) - use timestamp objects for time-based x-axis
                const importData = (history.import || []).map(record => {
                    // Strip timezone to prevent browser timezone conversion
                    const timestampStr = record.timestamp.replace(/[+-]\d{2}:\d{2}|Z$/, '');
                    const date = new Date(timestampStr);
                    return {
                        x: date.getTime(),
                        y: record.per_kwh
                    };
                });

                // Process export prices (sell/feed-in prices)
                // Note: Amber returns export prices as negative (e.g., -16c = earn 16c)
                // We negate them to show as positive for better buy/sell spread visualization
                const exportData = (history.export || []).map(record => {
                    // Strip timezone to prevent browser timezone conversion
                    const timestampStr = record.timestamp.replace(/[+-]\d{2}:\d{2}|Z$/, '');
                    const date = new Date(timestampStr);
                    return {
                        x: date.getTime(),
                        y: -record.per_kwh  // Negate to show as positive
                    };
                });

                // Build datasets array
                const datasets = [];

                // Get max prices from metadata (calculated from ALL day's data, not just chart data)
                const maxImportPrice = metadata?.max_import_price || 0;
                const maxExportPrice = metadata?.max_export_price || 0;

                // Add import dataset if we have data
                if (importData.length > 0) {
                    datasets.push({
                        label: 'Import Price (¬¢/kWh)',
                        data: importData,
                        borderColor: 'rgb(75, 192, 192)',
                        backgroundColor: 'rgba(75, 192, 192, 0.1)',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0,
                        pointHoverRadius: 6,
                        pointHitRadius: 30,
                        fill: true,
                        spanGaps: true
                    });
                }

                // Add export dataset if we have data
                if (exportData.length > 0) {
                    datasets.push({
                        label: 'Export Price (¬¢/kWh)',
                        data: exportData,
                        borderColor: 'rgb(255, 193, 7)', // Yellow
                        backgroundColor: 'rgba(255, 193, 7, 0.1)',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0,
                        pointHoverRadius: 6,
                        pointHitRadius: 30,
                        fill: true,
                        spanGaps: true
                    });
                }

                // Configure x-axis for midnight-to-midnight display
                let xAxisConfig = {
                    title: {
                        display: true,
                        text: 'Time'
                    }
                };

                // If we have metadata, use fixed min/max for midnight-to-midnight display
                if (metadata) {
                    const startStr = metadata.start_of_day.replace(/[+-]\d{2}:\d{2}|Z$/, '');
                    const endStr = metadata.end_of_day.replace(/[+-]\d{2}:\d{2}|Z$/, '');
                    const startOfDay = new Date(startStr);
                    const endOfDay = new Date(endStr);

                    xAxisConfig = {
                        type: 'time',
                        min: startOfDay.getTime(),
                        max: endOfDay.getTime(),
                        time: {
                            unit: 'hour',
                            displayFormats: {
                                hour: 'h a'
                            },
                            tooltipFormat: 'h:mm a'
                        },
                        ticks: {
                            autoSkip: false,
                            maxRotation: 0,
                            minRotation: 0,
                            callback: function(value, index, ticks) {
                                const date = new Date(value);
                                const hour = date.getHours();
                                // Show labels for 0, 6, 12, 18 hours only
                                if (hour === 0) {
                                    return '12 AM';
                                } else if (hour === 6) {
                                    return '6 AM';
                                } else if (hour === 12) {
                                    return '12 PM';
                                } else if (hour === 18) {
                                    return '6 PM';
                                }
                                return '';
                            }
                        },
                        title: {
                            display: true,
                            text: 'Time'
                        }
                    };
                }

                priceChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                            axis: 'x'
                        },
                        plugins: {
                            crosshair: {
                                line: {
                                    color: 'rgba(255, 99, 132, 0.7)',
                                    width: 1,
                                    dashPattern: [5, 5]
                                },
                                sync: {
                                    enabled: false
                                },
                                zoom: {
                                    enabled: false
                                }
                            },
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                enabled: true,
                                mode: 'index',
                                intersect: false,
                                filter: function(tooltipItem, index, tooltipItems) {
                                    // Remove duplicate entries with same label
                                    const label = tooltipItem.dataset.label;
                                    const firstIndex = tooltipItems.findIndex(item => item.dataset.label === label);
                                    return tooltipItems.indexOf(tooltipItem) === firstIndex;
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: false,
                                title: {
                                    display: true,
                                    text: 'Price (¬¢/kWh)'
                                }
                            },
                            x: xAxisConfig
                        }
                    }
                });
            } catch (error) {
                console.error('Error fetching price history:', error);
            }
        }

        // Fetch and display TOU tariff schedule
        let forecastChart = null;
        async function fetchTOUSchedule() {
            try {
                const response = await fetch('/api/tou-schedule');
                if (!response.ok) {
                    throw new Error('Failed to fetch TOU schedule');
                }
                const data = await response.json();

                const content = document.getElementById('tou-schedule-content');
                let html = '';

                // Display stats
                const stats = data.stats;
                if (stats) {
                    html += `<div class="grid" style="margin-bottom: 1em;">
                        <div style="text-align: center;">
                            <p style="margin: 0; font-size: 0.9em; color: #888;">Buy Price Range</p>
                            <p style="margin: 0; font-size: 1.3em;"><strong>${stats.buy.min.toFixed(1)}¬¢ - ${stats.buy.max.toFixed(1)}¬¢</strong></p>
                            <p style="margin: 0; font-size: 0.85em; color: #666;">Avg: ${stats.buy.avg.toFixed(1)}¬¢/kWh</p>
                        </div>
                        <div style="text-align: center;">
                            <p style="margin: 0; font-size: 0.9em; color: #888;">Sell Price Range</p>
                            <p style="margin: 0; font-size: 1.3em;"><strong>${stats.sell.min.toFixed(1)}¬¢ - ${stats.sell.max.toFixed(1)}¬¢</strong></p>
                            <p style="margin: 0; font-size: 0.85em; color: #666;">Avg: ${stats.sell.avg.toFixed(1)}¬¢/kWh</p>
                        </div>
                        <div style="text-align: center;">
                            <p style="margin: 0; font-size: 0.9em; color: #888;">Total Periods</p>
                            <p style="margin: 0; font-size: 1.3em;"><strong>${stats.total_periods}</strong></p>
                            <p style="margin: 0; font-size: 0.85em; color: #666;">30-min intervals</p>
                        </div>
                    </div>`;

                    html += `<p style="font-size: 0.9em; color: #666; margin-bottom: 1em;">
                        Tariff: ${data.tariff_name || 'Unknown'}
                    </p>`;
                }

                // Display tariff table
                const periods = data.periods || [];
                if (periods.length > 0) {
                    html += `<div style="max-height: 400px; overflow-y: auto;">
                        <table style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                            <thead style="position: sticky; top: 0; background: #1e1e1e;">
                                <tr style="border-bottom: 2px solid #444;">
                                    <th style="text-align: left; padding: 0.5em;">Time</th>
                                    <th style="text-align: right; padding: 0.5em;">Buy (¬¢/kWh)</th>
                                    <th style="text-align: right; padding: 0.5em;">Sell (¬¢/kWh)</th>
                                </tr>
                            </thead>
                            <tbody>`;

                    periods.forEach((period, i) => {
                        const buyColor = period.buy_price > stats.buy.avg * 1.2 ? '#ff6b6b' :
                                        period.buy_price < stats.buy.avg * 0.8 ? '#51cf66' : '#fff';
                        const sellColor = period.sell_price > stats.sell.avg * 1.2 ? '#51cf66' :
                                         period.sell_price < stats.sell.avg * 0.8 ? '#ff6b6b' : '#fff';

                        // Use is_current flag from backend (calculated in user's timezone)
                        const isCurrentPeriod = period.is_current || false;
                        const usesActualInterval = period.uses_actual_interval || false;
                        const chipModeSuppressed = period.chip_mode_suppressed || false;
                        const exportBoostActive = period.export_boost_active || false;

                        // Add visual indicators for current period, chip mode, and export boost
                        let rowStyle = 'border-bottom: 1px solid #333;';
                        if (isCurrentPeriod) {
                            rowStyle = 'border-bottom: 1px solid #333; background: rgba(81, 207, 102, 0.15); border-left: 3px solid #51cf66;';
                        } else if (chipModeSuppressed) {
                            rowStyle = 'border-bottom: 1px solid #333; background: rgba(255, 193, 7, 0.1);';
                        } else if (exportBoostActive) {
                            rowStyle = 'border-bottom: 1px solid #333; background: rgba(0, 191, 255, 0.1);';
                        }

                        // Show ActualInterval indicator if current period uses it
                        let timeDisplay = period.time;
                        if (isCurrentPeriod) {
                            timeDisplay = usesActualInterval
                                ? `<strong>‚ñ∂ ${period.time}</strong> <span style="color: #22c55e; font-size: 0.8em;">‚ö° Live</span>`
                                : `<strong>‚ñ∂ ${period.time}</strong>`;
                        }

                        // Show Chip Mode or Export Boost indicator
                        let modeIndicator = '';
                        if (chipModeSuppressed) {
                            modeIndicator = '<span style="color: #ffc107; font-size: 0.8em; margin-left: 0.5em;" title="Chip Mode: Export suppressed">üîí</span>';
                        } else if (exportBoostActive) {
                            modeIndicator = '<span style="color: #00bfff; font-size: 0.8em; margin-left: 0.5em;" title="Export Boost: Price boosted">üöÄ</span>';
                        }

                        html += `<tr style="${rowStyle}">
                            <td style="padding: 0.5em;">${timeDisplay}${modeIndicator}</td>
                            <td style="text-align: right; padding: 0.5em; color: ${buyColor}; font-weight: bold;">
                                ${period.buy_price.toFixed(2)}
                            </td>
                            <td style="text-align: right; padding: 0.5em; color: ${sellColor}; font-weight: bold;">
                                ${period.sell_price.toFixed(2)}
                            </td>
                        </tr>`;
                    });

                    html += `</tbody></table></div>`;

                    // Check if any periods have chip mode or export boost active
                    const hasChipMode = periods.some(p => p.chip_mode_suppressed);
                    const hasExportBoost = periods.some(p => p.export_boost_active);
                    const chipModeLegend = hasChipMode
                        ? '<span style="color: #ffc107;">üîí</span> Chip Mode (export suppressed) &nbsp;'
                        : '';
                    const exportBoostLegend = hasExportBoost
                        ? '<span style="color: #00bfff;">üöÄ</span> Export Boost (price boosted) &nbsp;'
                        : '';

                    html += `<p style="font-size: 0.8em; color: #666; margin-top: 1em;">
                        <span style="color: #51cf66;">‚ñ∂</span> Current period &nbsp;
                        <span style="color: #22c55e;">‚ö° Live</span> = Using ActualInterval (5-min actual price) &nbsp;
                        ${chipModeLegend}${exportBoostLegend}
                        <span style="color: #51cf66;">‚óè</span> Green = Good price &nbsp;
                        <span style="color: #ff6b6b;">‚óè</span> Red = High price &nbsp;
                        <span style="color: #fff;">‚óè</span> White = Average
                    </p>`;
                }

                content.innerHTML = html;

                // Update chart
                if (periods.length > 0) {
                    updateTariffChart(periods);
                }

            } catch (error) {
                console.error('Error fetching TOU schedule:', error);
                document.getElementById('tou-schedule-content').innerHTML =
                    '<p style="color: red;">Error loading tariff schedule. Please check your Amber API configuration in Settings.</p>';
            }
        }

        function updateTariffChart(periods) {
            const ctx = document.getElementById('forecastChart').getContext('2d');

            // Destroy existing chart if it exists
            if (forecastChart) {
                forecastChart.destroy();
            }

            // Extract labels and data from periods
            const labels = periods.map(period => period.time);
            const buyPrices = periods.map(period => period.buy_price);
            const sellPrices = periods.map(period => period.sell_price);

            // Find current period index for vertical line using backend-calculated flag
            let currentPeriodIndex = -1;
            periods.forEach((period, i) => {
                if (period.is_current) {
                    currentPeriodIndex = i;
                }
            });

            // Prepare annotation for current time
            const annotations = {};
            if (currentPeriodIndex >= 0) {
                annotations.currentTime = {
                    type: 'line',
                    xMin: currentPeriodIndex,
                    xMax: currentPeriodIndex,
                    borderColor: 'rgba(81, 207, 102, 0.8)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    label: {
                        display: true,
                        content: 'NOW',
                        position: 'start',
                        backgroundColor: 'rgba(81, 207, 102, 0.8)',
                        color: '#1e1e1e',
                        font: {
                            weight: 'bold',
                            size: 11
                        },
                        padding: 4
                    }
                };
            }

            forecastChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Buy Price (¬¢/kWh)',
                            data: buyPrices,
                            borderColor: 'rgb(255, 99, 132)',
                            backgroundColor: 'rgba(255, 99, 132, 0.1)',
                            borderWidth: 2,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHoverRadius: 4,
                            fill: true
                        },
                        {
                            label: 'Sell Price (¬¢/kWh)',
                            data: sellPrices,
                            borderColor: 'rgb(75, 192, 75)',
                            backgroundColor: 'rgba(75, 192, 75, 0.1)',
                            borderWidth: 2,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHoverRadius: 4,
                            fill: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        crosshair: {
                            line: {
                                color: 'rgba(76, 175, 80, 0.7)',
                                width: 1,
                                dashPattern: [5, 5]
                            },
                            sync: {
                                enabled: false
                            },
                            zoom: {
                                enabled: false
                            }
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            filter: function(tooltipItem, index, tooltipItems) {
                                // Remove duplicate entries with same label
                                const label = tooltipItem.dataset.label;
                                const firstIndex = tooltipItems.findIndex(item => item.dataset.label === label);
                                return tooltipItems.indexOf(tooltipItem) === firstIndex;
                            },
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + '¬¢/kWh';
                                }
                            }
                        },
                        annotation: {
                            annotations: annotations
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: 'Price (¬¢/kWh)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Time (24-hour rolling window)'
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                autoSkip: true,
                                maxTicksLimit: 12
                            }
                        }
                    }
                }
            });
        }

        // Sync to Tesla handler
        async function syncTeslaSchedule() {
            const syncBtn = document.getElementById('sync-tesla-btn');
            const syncStatus = document.getElementById('sync-status');

            try {
                // Disable button and show loading state
                syncBtn.disabled = true;
                syncBtn.textContent = 'Syncing...';
                syncStatus.innerHTML = '<p style="color: blue;">‚è≥ Syncing schedule to Tesla Powerwall...</p>';

                const response = await fetch('/api/sync-tesla-schedule', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const result = await response.json();

                if (response.ok && result.success) {
                    syncStatus.innerHTML = `
                        <p style="color: green;">‚úÖ ${result.message}</p>
                        <p style="font-size: 0.9em; margin: 0.5em 0;">
                            Updated ${result.rate_periods} pricing periods to Tesla.
                            Tariff: ${result.tariff_name}
                        </p>
                    `;
                    // Auto-hide success message after 10 seconds
                    setTimeout(() => {
                        syncStatus.innerHTML = '';
                    }, 10000);
                } else {
                    throw new Error(result.error || 'Failed to sync schedule');
                }
            } catch (error) {
                console.error('Error syncing Tesla schedule:', error);
                syncStatus.innerHTML = `<p style="color: red;">‚ùå Error: ${error.message}</p>`;
            } finally {
                // Re-enable button
                syncBtn.disabled = false;
                syncBtn.textContent = 'Sync to Tesla';
            }
        }

        // Toggle automatic syncing
        async function toggleSync() {
            const toggleBtn = document.getElementById('toggle-sync-btn');
            const syncStatusText = document.getElementById('sync-status-text');
            const syncStatus = document.getElementById('sync-status');

            try {
                // Disable button during request
                toggleBtn.disabled = true;

                const response = await fetch('/api/toggle-sync', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const result = await response.json();

                if (response.ok && result.success) {
                    // Update button appearance and text
                    syncStatusText.textContent = result.sync_enabled ? 'ON' : 'OFF';
                    toggleBtn.className = result.sync_enabled ? 'secondary' : 'contrast';

                    // Show status message
                    const statusColor = result.sync_enabled ? 'green' : 'orange';
                    const statusIcon = result.sync_enabled ? '‚úÖ' : '‚è∏Ô∏è';
                    syncStatus.innerHTML = `<p style="color: ${statusColor};">${statusIcon} ${result.message}</p>`;

                    // Auto-hide message after 5 seconds
                    setTimeout(() => {
                        syncStatus.innerHTML = '';
                    }, 5000);
                } else {
                    throw new Error(result.error || 'Failed to toggle sync');
                }
            } catch (error) {
                console.error('Error toggling sync:', error);
                syncStatus.innerHTML = `<p style="color: red;">‚ùå Error: ${error.message}</p>`;
            } finally {
                // Re-enable button
                toggleBtn.disabled = false;
            }
        }

        // Refresh button handler
        document.getElementById('refresh-schedule-btn')?.addEventListener('click', fetchTOUSchedule);

        // Sync button handler
        document.getElementById('sync-tesla-btn')?.addEventListener('click', syncTeslaSchedule);

        // Toggle sync button handler
        document.getElementById('toggle-sync-btn')?.addEventListener('click', toggleSync);

        // Initial load
        checkAPIStatus();
        fetchTOUSchedule();
        fetchPriceHistory();
        generate30MinForecast();

        // Refresh current prices every 1 minute (Amber updates every 5 mins, so we catch updates quickly)
        setInterval(fetchCurrentPrices, 60 * 1000);
        // Refresh 30-min forecast every 5 minutes
        setInterval(generate30MinForecast, 5 * 60 * 1000);
        // Check API status every 5 minutes
        setInterval(checkAPIStatus, 5 * 60 * 1000);
        // Refresh TOU schedule every 30 minutes (aligned with Amber's update cycle at :00 and :30)
        setInterval(fetchTOUSchedule, 30 * 60 * 1000);
        // Fetch energy usage history on load and when timeframe changes
        fetchEnergyUsageHistory();
        document.getElementById('timeframe-selector').addEventListener('change', fetchEnergyUsageHistory);
        // Refresh energy charts every 30 seconds
        setInterval(fetchEnergyUsageHistory, 30 * 1000);

        // Populate price day selector with actual dates
        function populatePriceDaySelector() {
            const selector = document.getElementById('price-day-selector');
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            // Add "Today" option
            const todayOption = document.createElement('option');
            todayOption.value = 'today';
            todayOption.textContent = 'Today';
            todayOption.selected = true;
            selector.appendChild(todayOption);

            // Add previous days with actual dates
            for (let i = 1; i <= 6; i++) {
                const date = new Date();
                date.setDate(date.getDate() - i);

                const day = date.getDate();
                const month = monthNames[date.getMonth()];

                const option = document.createElement('option');
                option.value = i === 1 ? 'yesterday' : i.toString();
                option.textContent = `${day} ${month}`;
                selector.appendChild(option);
            }
        }

        populatePriceDaySelector();

        // Add event listener for price history day selector
        document.getElementById('price-day-selector').addEventListener('change', fetchPriceHistory);

        // Energy Usage Charts
        let solarChart = null;
        let gridChart = null;
        let batteryChart = null;
        let loadChart = null;

        async function fetchEnergyUsageHistory() {
            try {
                const timeframe = document.getElementById('timeframe-selector').value;
                const response = await fetch(`/api/energy-history?timeframe=${timeframe}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch energy history');
                }
                const history = await response.json();

                // Handle both old format (array) and new format (object with records)
                const records = Array.isArray(history) ? history : history.records || [];
                const metadata = history.metadata || null;

                if (records.length === 0) {
                    return;
                }

                // Prepare data with timestamps for proper time-based plotting
                // Strip timezone info to prevent Chart.js from converting to browser timezone
                let dataPoints = records.map(record => {
                    // Strip timezone offset (everything after +/- or Z) to get naive datetime
                    const timestampStr = record.timestamp.replace(/[+-]\d{2}:\d{2}|Z$/, '');
                    return {
                        timestamp: new Date(timestampStr),
                        solar: record.solar_power / 1000,
                        grid: record.grid_power / 1000,
                        battery: record.battery_power / 1000,
                        load: record.load_power / 1000
                    };
                });

                // Filter to only show readings at 5-minute intervals for cleaner visualization
                dataPoints = dataPoints.filter(point => {
                    const minutes = point.timestamp.getMinutes();
                    // Keep readings where minutes are divisible by 5 (0, 5, 10, 15, etc.)
                    return minutes % 5 === 0;
                });

                // For 'day' timeframe, use backend-provided date range (in user's configured timezone)
                let xAxisConfig = null;
                if (timeframe === 'day' && metadata) {
                    // Strip timezone from metadata dates to prevent browser timezone conversion
                    const startStr = metadata.start_of_day.replace(/[+-]\d{2}:\d{2}|Z$/, '');
                    const endStr = metadata.end_of_day.replace(/[+-]\d{2}:\d{2}|Z$/, '');
                    const startOfDay = new Date(startStr);
                    const endOfDay = new Date(endStr);

                    xAxisConfig = {
                        type: 'time',
                        min: startOfDay.getTime(),
                        max: endOfDay.getTime(),
                        time: {
                            unit: 'hour',
                            displayFormats: {
                                hour: 'h a'
                            },
                            tooltipFormat: 'h:mm a'
                        },
                        ticks: {
                            autoSkip: false,
                            maxRotation: 0,
                            minRotation: 0,
                            callback: function(value, index, ticks) {
                                const date = new Date(value);
                                const hour = date.getHours();

                                // Show labels for 0, 6, 12, 18 hours only
                                if (hour === 0) {
                                    return '12 AM';
                                } else if (hour === 6) {
                                    return '6 AM';
                                } else if (hour === 12) {
                                    return '12 PM';
                                } else if (hour === 18) {
                                    return '6 PM';
                                }
                                return '';
                            }
                        },
                        adapters: {
                            date: {}
                        }
                    };
                }

                // Update current real-time values (most recent reading)
                try {
                    if (records && records.length > 0) {
                        const latest = records[records.length - 1];

                        // Helper function to format power with appropriate units
                        function formatPower(watts) {
                            if (watts == null || isNaN(watts)) {
                                return '-- W';
                            }
                            if (Math.abs(watts) >= 1000) {
                                return `${(watts / 1000).toFixed(2)} kW`;
                            }
                            return `${watts.toFixed(0)} W`;
                        }

                        // Solar (always positive generation)
                        const solarElem = document.getElementById('solar-current-value');
                        if (solarElem) {
                            solarElem.textContent = formatPower(latest.solar_power);
                        }

                        // Grid (+ importing, - exporting)
                        const gridElem = document.getElementById('grid-current-value');
                        if (gridElem && latest.grid_power != null) {
                            if (latest.grid_power > 50) {
                                gridElem.innerHTML = `‚Üì ${formatPower(latest.grid_power)} <span style="color: #e74c3c;">(importing)</span>`;
                            } else if (latest.grid_power < -50) {
                                gridElem.innerHTML = `‚Üë ${formatPower(Math.abs(latest.grid_power))} <span style="color: #27ae60;">(exporting)</span>`;
                            } else {
                                gridElem.textContent = formatPower(latest.grid_power);
                            }
                        }

                        // Battery (+ discharging/exporting, - charging)
                        const batteryElem = document.getElementById('battery-current-value');
                        if (batteryElem && latest.battery_power != null) {
                            if (latest.battery_power > 50) {
                                batteryElem.innerHTML = `‚Üë ${formatPower(latest.battery_power)} <span style="color: #e67e22;">(discharging)</span>`;
                            } else if (latest.battery_power < -50) {
                                batteryElem.innerHTML = `‚Üì ${formatPower(Math.abs(latest.battery_power))} <span style="color: #3498db;">(charging)</span>`;
                            } else {
                                batteryElem.textContent = formatPower(Math.abs(latest.battery_power));
                            }
                        }

                        // Load (home consumption)
                        const loadElem = document.getElementById('load-current-value');
                        if (loadElem) {
                            loadElem.textContent = formatPower(latest.load_power);
                        }

                        console.log('Updated energy values:', {
                            solar: latest.solar_power,
                            grid: latest.grid_power,
                            battery: latest.battery_power,
                            load: latest.load_power
                        });
                    }
                } catch (error) {
                    console.error('Error updating current energy values:', error);
                }

                // Calculate daily energy totals (integrate power over time)
                try {
                    if (dataPoints.length > 1) {
                        let solarEnergy = 0;
                        let gridEnergyImport = 0;
                        let gridEnergyExport = 0;
                        let batteryEnergyCharge = 0;
                        let batteryEnergyDischarge = 0;
                        let loadEnergy = 0;

                        // Integrate power over time using trapezoidal rule
                        for (let i = 1; i < dataPoints.length; i++) {
                            const prevPoint = dataPoints[i - 1];
                            const currPoint = dataPoints[i];

                            // Time difference in hours
                            const timeDiffHours = (currPoint.timestamp - prevPoint.timestamp) / (1000 * 60 * 60);

                            // Energy = average power √ó time (trapezoidal rule)
                            const avgSolar = (prevPoint.solar + currPoint.solar) / 2;
                            const avgGrid = (prevPoint.grid + currPoint.grid) / 2;
                            const avgBattery = (prevPoint.battery + currPoint.battery) / 2;
                            const avgLoad = (prevPoint.load + currPoint.load) / 2;

                            solarEnergy += avgSolar * timeDiffHours;

                            // Grid: separate import and export
                            if (avgGrid > 0) {
                                gridEnergyImport += avgGrid * timeDiffHours;
                            } else {
                                gridEnergyExport += Math.abs(avgGrid) * timeDiffHours;
                            }

                            // Battery: separate charge and discharge
                            if (avgBattery > 0) {
                                batteryEnergyDischarge += avgBattery * timeDiffHours;
                            } else {
                                batteryEnergyCharge += Math.abs(avgBattery) * timeDiffHours;
                            }

                            loadEnergy += avgLoad * timeDiffHours;
                        }

                        // Update solar total
                        const solarTotalElem = document.getElementById('solar-daily-total');
                        if (solarTotalElem) {
                            solarTotalElem.textContent = solarEnergy.toFixed(1) + ' kWh';
                        }

                        // Update grid total (net or show import/export)
                        const gridTotalElem = document.getElementById('grid-daily-total');
                        const gridLabelElem = document.getElementById('grid-daily-label');
                        if (gridTotalElem && gridLabelElem) {
                            const gridNet = gridEnergyImport - gridEnergyExport;
                            if (Math.abs(gridNet) < 0.1) {
                                gridTotalElem.textContent = '0.0 kWh';
                                gridLabelElem.textContent = 'Net';
                            } else if (gridNet > 0) {
                                gridTotalElem.textContent = gridEnergyImport.toFixed(1) + ' kWh';
                                gridLabelElem.textContent = 'Imported';
                                gridTotalElem.style.color = '#e74c3c';
                            } else {
                                gridTotalElem.textContent = gridEnergyExport.toFixed(1) + ' kWh';
                                gridLabelElem.textContent = 'Exported';
                                gridTotalElem.style.color = '#27ae60';
                            }
                        }

                        // Update battery total (net or show charge/discharge)
                        const batteryTotalElem = document.getElementById('battery-daily-total');
                        const batteryLabelElem = document.getElementById('battery-daily-label');
                        if (batteryTotalElem && batteryLabelElem) {
                            const batteryNet = batteryEnergyDischarge - batteryEnergyCharge;
                            if (Math.abs(batteryNet) < 0.1) {
                                batteryTotalElem.textContent = '0.0 kWh';
                                batteryLabelElem.textContent = 'Net';
                            } else if (batteryNet > 0) {
                                batteryTotalElem.textContent = batteryEnergyDischarge.toFixed(1) + ' kWh';
                                batteryLabelElem.textContent = 'Discharged';
                                batteryTotalElem.style.color = '#e67e22';
                            } else {
                                batteryTotalElem.textContent = batteryEnergyCharge.toFixed(1) + ' kWh';
                                batteryLabelElem.textContent = 'Charged';
                                batteryTotalElem.style.color = '#3498db';
                            }
                        }

                        // Update load total
                        const loadTotalElem = document.getElementById('load-daily-total');
                        if (loadTotalElem) {
                            loadTotalElem.textContent = loadEnergy.toFixed(1) + ' kWh';
                        }

                        console.log('Daily energy totals:', {
                            solar: solarEnergy.toFixed(2),
                            gridImport: gridEnergyImport.toFixed(2),
                            gridExport: gridEnergyExport.toFixed(2),
                            batteryCharge: batteryEnergyCharge.toFixed(2),
                            batteryDischarge: batteryEnergyDischarge.toFixed(2),
                            load: loadEnergy.toFixed(2)
                        });
                    }
                } catch (error) {
                    console.error('Error calculating daily energy totals:', error);
                }

                // Update charts
                updateEnergyChart('solarChart', solarChart, dataPoints, 'solar', 'Solar Generation (kW)', 'rgb(255, 193, 7)', xAxisConfig, (chart) => { solarChart = chart; });
                updateEnergyChart('gridChart', gridChart, dataPoints, 'grid', 'Grid Power (kW)', 'rgb(76, 175, 80)', xAxisConfig, (chart) => { gridChart = chart; });
                updateEnergyChart('batteryChart', batteryChart, dataPoints, 'battery', 'Battery Power (kW)', 'rgb(33, 150, 243)', xAxisConfig, (chart) => { batteryChart = chart; });
                updateEnergyChart('loadChart', loadChart, dataPoints, 'load', 'Home Load (kW)', 'rgb(156, 39, 176)', xAxisConfig, (chart) => { loadChart = chart; });

            } catch (error) {
                console.error('Error fetching energy usage history:', error);
            }
        }

        function updateEnergyChart(canvasId, existingChart, dataPoints, dataKey, label, color, xAxisConfig, setChart) {
            const ctx = document.getElementById(canvasId).getContext('2d');

            // Destroy existing chart if it exists
            if (existingChart) {
                existingChart.destroy();
            }

            // Transform data points to Chart.js format
            // Data is already filtered to 5-minute intervals (max 288 points per day)
            const chartData = dataPoints.map(point => ({
                x: point.timestamp,
                y: point[dataKey]
            }));

            // Configure x-axis (use provided config for day view, or default for other timeframes)
            const xAxis = xAxisConfig || {
                ticks: {
                    maxRotation: 45,
                    minRotation: 45
                }
            };

            // Calculate y-axis configuration with auto-scaling
            // Find min/max values for better visualization
            const yValues = chartData.map(d => d.y).filter(v => v != null);
            const yMin = Math.min(...yValues);
            const yMax = Math.max(...yValues);
            const yRange = yMax - yMin;

            // Add 10% padding to top and bottom for better visualization
            const suggestedMin = yMin - (yRange * 0.1);
            const suggestedMax = yMax + (yRange * 0.1);

            const newChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: label,
                        data: chartData,
                        borderColor: color,
                        backgroundColor: color.replace('rgb', 'rgba').replace(')', ', 0.1)'),
                        borderWidth: 2,
                        tension: 0.3, // Smooth curves for 5-minute interval data
                        pointRadius: 0,
                        pointHoverRadius: 6,
                        pointHitRadius: 30,
                        fill: true,
                        spanGaps: true // Connect points even when there are gaps in data
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: true,
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            cornerRadius: 6,
                            titleFont: {
                                size: 14,
                                weight: 'bold'
                            },
                            bodyFont: {
                                size: 13
                            },
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(2) + ' kW';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            // Auto-scale based on data range with padding
                            suggestedMin: Math.max(0, suggestedMin), // Don't go below 0 for positive-only values
                            suggestedMax: suggestedMax,
                            grace: '5%', // Additional grace padding
                            title: {
                                display: true,
                                text: label
                            },
                            ticks: {
                                // Limit number of ticks for cleaner display
                                maxTicksLimit: 6
                            }
                        },
                        x: xAxis
                    }
                }
            });

            setChart(newChart);
        }

        // Energy Summaries from Tesla Calendar History
        async function fetchEnergySummaries() {
            try {
                const period = document.getElementById('summary-period-selector').value;
                const response = await fetch(`/api/energy-calendar-history?period=${period}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch energy summaries');
                }
                const data = await response.json();

                if (!data.time_series || data.time_series.length === 0) {
                    document.getElementById('energy-summaries-content').innerHTML = '<p style="color: #888;">No historical data available for this period.</p>';
                    return;
                }

                // Calculate totals from time series
                let totalSolar = 0;
                let totalGridImport = 0;
                let totalGridExport = 0;
                let totalBatteryCharge = 0;
                let totalBatteryDischarge = 0;
                let totalConsumer = 0;

                data.time_series.forEach(entry => {
                    totalSolar += entry.solar_energy_exported || 0;
                    totalGridImport += entry.grid_energy_imported || 0;
                    totalGridExport += entry.grid_energy_exported_from_solar || 0;
                    totalGridExport += entry.grid_energy_exported_from_battery || 0;
                    totalBatteryCharge += entry.battery_energy_imported_from_grid || 0;
                    totalBatteryCharge += entry.battery_energy_imported_from_solar || 0;
                    totalBatteryDischarge += entry.battery_energy_exported || 0;
                    totalConsumer += entry.consumer_energy_imported_from_grid || 0;
                    totalConsumer += entry.consumer_energy_imported_from_solar || 0;
                    totalConsumer += entry.consumer_energy_imported_from_battery || 0;
                });

                // Display summaries in a grid
                const summariesHTML = `
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1em;">
                        <div style="background: rgba(255, 193, 7, 0.1); border-left: 4px solid rgb(255, 193, 7); padding: 1em;">
                            <h4 style="margin: 0; color: rgb(255, 193, 7);">Solar Generated</h4>
                            <p style="font-size: 2em; margin: 0.5em 0 0 0;">${(totalSolar / 1000).toFixed(1)} kWh</p>
                        </div>
                        <div style="background: rgba(76, 175, 80, 0.1); border-left: 4px solid rgb(76, 175, 80); padding: 1em;">
                            <h4 style="margin: 0; color: rgb(76, 175, 80);">Grid Import</h4>
                            <p style="font-size: 2em; margin: 0.5em 0 0 0;">${(totalGridImport / 1000).toFixed(1)} kWh</p>
                        </div>
                        <div style="background: rgba(139, 195, 74, 0.1); border-left: 4px solid rgb(139, 195, 74); padding: 1em;">
                            <h4 style="margin: 0; color: rgb(139, 195, 74);">Grid Export</h4>
                            <p style="font-size: 2em; margin: 0.5em 0 0 0;">${(totalGridExport / 1000).toFixed(1)} kWh</p>
                        </div>
                        <div style="background: rgba(33, 150, 243, 0.1); border-left: 4px solid rgb(33, 150, 243); padding: 1em;">
                            <h4 style="margin: 0; color: rgb(33, 150, 243);">Battery Charge</h4>
                            <p style="font-size: 2em; margin: 0.5em 0 0 0;">${(totalBatteryCharge / 1000).toFixed(1)} kWh</p>
                        </div>
                        <div style="background: rgba(63, 81, 181, 0.1); border-left: 4px solid rgb(63, 81, 181); padding: 1em;">
                            <h4 style="margin: 0; color: rgb(63, 81, 181);">Battery Discharge</h4>
                            <p style="font-size: 2em; margin: 0.5em 0 0 0;">${(totalBatteryDischarge / 1000).toFixed(1)} kWh</p>
                        </div>
                        <div style="background: rgba(156, 39, 176, 0.1); border-left: 4px solid rgb(156, 39, 176); padding: 1em;">
                            <h4 style="margin: 0; color: rgb(156, 39, 176);">Home Consumption</h4>
                            <p style="font-size: 2em; margin: 0.5em 0 0 0;">${(totalConsumer / 1000).toFixed(1)} kWh</p>
                        </div>
                    </div>
                    <p style="margin-top: 1em; color: #666; font-size: 0.9em;">
                        <strong>Period:</strong> ${period === 'day' ? 'Today' : period === 'week' ? 'This Week' : period === 'month' ? 'This Month' : 'This Year'}
                        (${data.time_series.length} ${data.time_series.length === 1 ? 'day' : 'days'})
                    </p>
                `;

                document.getElementById('energy-summaries-content').innerHTML = summariesHTML;

            } catch (error) {
                console.error('Error fetching energy summaries:', error);
                document.getElementById('energy-summaries-content').innerHTML = '<p style="color: red;">Error loading energy summaries. Tesla calendar history may not be available.</p>';
            }
        }

        // Initialize summaries
        fetchEnergySummaries();
        document.getElementById('summary-period-selector').addEventListener('change', fetchEnergySummaries);
        document.getElementById('refresh-summaries-btn').addEventListener('click', fetchEnergySummaries);

        // ========================================
        // BATTERY HEALTH FUNCTIONS
        // ========================================

        let degradationChart = null;

        async function loadBatteryHealth() {
            try {
                const response = await fetch('/api/battery-health');
                const data = await response.json();

                document.getElementById('battery-health-loading').style.display = 'none';

                if (!data.has_data) {
                    document.getElementById('battery-health-no-data').style.display = 'block';
                    document.getElementById('battery-health-data').style.display = 'none';
                    return;
                }

                document.getElementById('battery-health-no-data').style.display = 'none';
                document.getElementById('battery-health-data').style.display = 'block';

                // Calculate health percent
                const healthPercent = data.currentCapacityWh && data.originalCapacityWh
                    ? (data.currentCapacityWh / data.originalCapacityWh * 100).toFixed(1)
                    : '--';
                // Calculate degradation: 100 - health percent (handle 0 which is falsy)
                let degradationPercent = '--';
                if (data.degradationPercent !== null && data.degradationPercent !== undefined) {
                    degradationPercent = data.degradationPercent.toFixed(1);
                } else if (healthPercent !== '--') {
                    // Calculate from health if not provided
                    degradationPercent = (100 - parseFloat(healthPercent)).toFixed(1);
                }

                // Update display
                document.getElementById('health-percent').textContent = healthPercent + '%';
                document.getElementById('degradation-percent').textContent = degradationPercent + '%';
                document.getElementById('actual-capacity').textContent = data.currentCapacityWh
                    ? (data.currentCapacityWh / 1000).toFixed(2) + ' kWh'
                    : '-- kWh';
                document.getElementById('rated-capacity').textContent = data.originalCapacityWh
                    ? (data.originalCapacityWh / 1000).toFixed(2) + ' kWh'
                    : '-- kWh';

                // Set install date if available
                if (data.installDate) {
                    const installDate = new Date(data.installDate);
                    document.getElementById('install-date-display').textContent = installDate.toLocaleDateString();
                } else {
                    document.getElementById('install-date-display').textContent = 'Not available';
                }

                // Update last updated timestamp
                if (data.updatedAt) {
                    const updated = new Date(data.updatedAt);
                    document.getElementById('battery-health-last-updated').textContent =
                        'Last scan: ' + updated.toLocaleDateString() + ' ' + updated.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                }

                // Color the health percent based on value
                const healthEl = document.getElementById('health-percent');
                const health = parseFloat(healthPercent);
                if (health >= 95) {
                    healthEl.style.color = '#22c55e'; // Green
                } else if (health >= 90) {
                    healthEl.style.color = '#84cc16'; // Lime
                } else if (health >= 80) {
                    healthEl.style.color = '#eab308'; // Yellow
                } else {
                    healthEl.style.color = '#ef4444'; // Red
                }

                // Load history for graph
                loadBatteryHealthHistory();

            } catch (error) {
                console.error('Error loading battery health:', error);
                document.getElementById('battery-health-loading').style.display = 'none';
                document.getElementById('battery-health-no-data').style.display = 'block';
            }
        }

        async function loadBatteryHealthHistory() {
            try {
                const response = await fetch('/api/battery-health/history');
                const data = await response.json();

                if (!data.history || data.history.length === 0) {
                    // No history data, hide the graph
                    document.getElementById('degradation-graph-details').style.display = 'none';
                    return;
                }

                document.getElementById('degradation-graph-details').style.display = 'block';

                // Build chart data
                const chartData = [];

                // Add install date as starting point (100% health, 0% degradation)
                if (data.installDate) {
                    chartData.push({
                        x: new Date(data.installDate),
                        y: 100,
                        degradation: 0
                    });
                }

                // Add historical data points
                for (const record of data.history) {
                    chartData.push({
                        x: new Date(record.date),
                        y: record.healthPercent,
                        degradation: record.degradationPercent
                    });
                }

                // Destroy existing chart if it exists
                if (degradationChart) {
                    degradationChart.destroy();
                }

                // Create the chart
                const ctx = document.getElementById('degradationChart').getContext('2d');
                degradationChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: 'Health %',
                            data: chartData,
                            borderColor: '#22c55e',
                            backgroundColor: 'rgba(34, 197, 94, 0.1)',
                            fill: true,
                            tension: 0.3,
                            pointRadius: 6,
                            pointHoverRadius: 8
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        layout: {
                            padding: {
                                left: 0,
                                right: 10
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                bounds: 'data',
                                offset: false,
                                min: chartData.length > 0 ? chartData[0].x.getTime() : undefined,
                                max: chartData.length > 0 ? chartData[chartData.length - 1].x.getTime() : undefined,
                                time: {
                                    unit: 'month',
                                    displayFormats: {
                                        month: 'MMM yyyy'
                                    }
                                },
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    source: 'data',
                                    maxRotation: 0
                                },
                                grid: {
                                    offset: false
                                },
                                afterFit: function(scale) {
                                    scale.paddingLeft = 0;
                                }
                            },
                            y: {
                                min: 80,
                                max: Math.max(110, ...chartData.map(d => d.y)) + 2,
                                title: {
                                    display: true,
                                    text: 'Health %'
                                },
                                ticks: {
                                    callback: function(value) {
                                        return value + '%';
                                    }
                                }
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    title: function(context) {
                                        const date = new Date(context[0].parsed.x);
                                        return date.toLocaleDateString('en-AU', { year: 'numeric', month: 'long', day: 'numeric' });
                                    },
                                    label: function(context) {
                                        const point = context.raw;
                                        return [
                                            'Health: ' + point.y.toFixed(1) + '%',
                                            'Degradation: ' + point.degradation.toFixed(1) + '%'
                                        ];
                                    }
                                }
                            },
                            legend: {
                                display: false
                            },
                            annotation: {
                                annotations: {
                                    warrantyLine: {
                                        type: 'line',
                                        yMin: 80,
                                        yMax: 80,
                                        borderColor: 'rgba(239, 68, 68, 0.5)',
                                        borderWidth: 2,
                                        borderDash: [5, 5],
                                        label: {
                                            display: true,
                                            content: 'Warranty Threshold (80%)',
                                            position: 'start',
                                            backgroundColor: 'rgba(239, 68, 68, 0.8)',
                                            font: { size: 10 }
                                        }
                                    }
                                }
                            }
                        }
                    }
                });

            } catch (error) {
                console.error('Error loading battery health history:', error);
            }
        }

        // Initialize battery health on page load
        document.addEventListener('DOMContentLoaded', loadBatteryHealth);
    </script>

    <style>
        .status-indicator {
            font-size: 1.5em;
        }
    </style>
{% endblock %}
